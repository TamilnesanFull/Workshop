'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var index = require('./index-3bdbdb42.cjs.dev.js');
var cx = require('./cx-26784cbb.cjs.dev.js');
var forwardRef = require('./forward-ref-6c731e6e.cjs.dev.js');
var context = require('./context-8bcac1ff.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-88b49271.cjs.dev.js');
var track = require('./track-1da464e0.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');
require('clsx');

const getFocusContainerTwStyles = ({
  isDisabled,
  isGhost,
  isInvalid
}) => {
  const state = getState(isDisabled, isGhost, isInvalid);
  return {
    adornmentEnd: ``,
    adornmentStart: ``,
    center: `
			flex
		`,
    control: `
			bg-transparent
			border-transparent
			grow
			peer
			shadow-none
		`,
    focusIndicator: `
			${focusContainerBorderLookup[state]}
			${getFocusContainerHighContrastBorder(state)}
			${getFocusContainerHoverStyles(state)}
			[transition-timing-function:ease]
			absolute
			border
			duration-300
			inset-0
			peer-focus-within:border-2
			peer-focus-within:border-input-active
			pointer-events-none
			rounded-8px
			transition-colors
		`,
    root: `
			${focusContainerBgLookUp[state]}
			flex
			group
			items-center
			outline-0
			overflow-hidden
			relative
			rounded-8px
		`
  };
};
function getState(isDisabled, isGhost, isInvalid) {
  if (isDisabled && isGhost) {
    return 'DISABLED_GHOST';
  } else if (isDisabled) {
    return 'DISABLED';
  } else if (isInvalid) {
    return 'INVALID';
  } else if (isGhost) {
    return 'GHOST';
  } else {
    return 'DEFAULT';
  }
}
function getFocusContainerHighContrastBorder(state) {
  if (['DISABLED', 'DISABLED_GHOST'].includes(state)) {
    return 'high-contrast:border-dotted';
  }
  return '';
}
function getFocusContainerHoverStyles(state) {
  if (state === 'DEFAULT') {
    return 'group-hover:border-input-hover';
  }
  if (state === 'INVALID') {
    return 'group-hover:border-input-critical-hover';
  }
  return '';
}
const focusContainerBgLookUp = {
  DISABLED_GHOST: `
		bg-transparent
		hover:focus-within:bg-transparent
	`,
  DISABLED: `
		bg-neutral-disabled
	`,
  GHOST: `
		hover:bg-neutral-hover
		hover:focus-within:bg-transparent
	`,
  INVALID: `
		bg-canvas
	`,
  DEFAULT: `
		bg-canvas
	`
};
const focusContainerBorderLookup = {
  DISABLED_GHOST: 'border-transparent',
  GHOST: 'border-transparent',
  DISABLED: 'border-input-disabled',
  INVALID: 'border-input-critical',
  DEFAULT: 'border-input'
};

/**
 * FocusContainer
 *
 * @description
 *
 * The FocusContainer is used internally to handle some shared styling between
 * components that are wrapped in the Field component.
 *
 * Typically adornments (icons or buttons that appear to be inside the control)
 * will be absolutely positioning above it and padding is applied to make sure
 * that text does not get obscured below the adornments.
 *
 * On top of this, password managers will insert buttons above the input which
 * can get in the way of our adornments.
 *
 * To get around these problems, we wrap the input and adornments with the
 * FocusContainer and apply our own focus styles to an absolutely positioned
 * element that is a sibling of the input (when the input is focused).
 *
 * The FocusContainer also provides the border and background styles and has
 * slots to place the start and end adornments.
 */

const FocusContainer = forwardRef.forwardRefWithGenericComponent(function FocusContainer({
  adornmentEnd,
  adornmentStart,
  children,
  className = '',
  classNames = {},
  isDisabled = false,
  isGhost = false,
  isInvalid = false,
  style = {},
  styles = {},
  ...consumerProps
}, forwardedRef) {
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getFocusContainerTwStyles({
      isDisabled,
      isGhost,
      isInvalid
    })
  });
  const rootStyles = styleProps('root');
  const centerStyles = styleProps('center');
  const trackStyleProps = {
    className: rootStyles.className,
    classNames: {
      center: centerStyles.className
    },
    style: rootStyles.style,
    styles: {
      center: centerStyles.style
    }
  };
  const ref = React.useRef();
  return /*#__PURE__*/jsxRuntime.jsx(context.FocusRefContextProvider, {
    value: ref,
    children: /*#__PURE__*/jsxRuntime.jsxs(track.Track, {
      ...consumerProps,
      railEnd: adornmentEnd ? /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        as: "span",
        ...styleProps('adornmentEnd'),
        children: adornmentEnd
      }) : null,
      railStart: adornmentStart ? /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        as: "span",
        ...styleProps('adornmentStart'),
        children: adornmentStart
      }) : null,
      ref: forwardedRef,
      ...trackStyleProps,
      children: [children({
        ref
      }), /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        "aria-hidden": "true",
        as: "span",
        ...styleProps('focusIndicator')
      })]
    })
  });
});
function useCombinedFocusContainerInputStyles({
  className,
  classNames,
  isDisabled,
  isGhost = false,
  isInvalid,
  style,
  styles,
  tw
}) {
  return index.getStyleProps({
    className: cx.cx(getFocusContainerTwStyles({
      isDisabled,
      isGhost,
      isInvalid
    }).control, className),
    classNames,
    style,
    styles,
    tw
  });
}

exports.FocusContainer = FocusContainer;
exports.useCombinedFocusContainerInputStyles = useCombinedFocusContainerInputStyles;
