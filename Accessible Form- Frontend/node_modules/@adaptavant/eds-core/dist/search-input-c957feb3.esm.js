'use client';
import { mergeRefs } from '@react-aria/utils';
import { forwardRef, useRef, useState, useCallback, useMemo } from 'react';
import { buttonSizeToIconSize } from './button-22306f71.esm.js';
import { R as RemoveIcon } from './remove-icon-2073e50f.esm.js';
import { S as SearchIcon } from './search-icon-9edceb5f.esm.js';
import { g as getStyleProps } from './index-dd10a77e.esm.js';
import { jsx } from 'react/jsx-runtime';
import { useFieldContext } from './context-2a1498a6.esm.js';
import { ClickableAdornment } from './clickable-adornment-0894b0d0.esm.js';
import { TextInput } from './text-input-2822fc45.esm.js';
import './styles-53001919.esm.js';
import './tw-c6a9a210.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';

const getSearchInputStyles = ({
  size,
  isDisabled
}) => ({
  root: `
		flex
		flex-nowrap
		flex-row
	`,
  adornmentStart: `
	    leading-none
		${adornmentStartOffsetLookup[size]}
		${isDisabled ? 'cursor-default text-disabled' : 'text-primary'}
	`,
  adornmentEnd: `
	    leading-none
		${adornmentEndOffsetLookup[size]}
		${isDisabled ? 'cursor-default text-disabled' : 'text-primary'}
	`
});
const adornmentStartOffsetLookup = {
  standard: 'ps-2',
  large: 'ps-3'
};
const adornmentEndOffsetLookup = {
  standard: 'pe-2',
  large: 'pe-3'
};

/**
 * SearchInput
 *
 * @description
 * A customizable input field for search functionality.
 * It includes features like clearing the input and handling escape key presses.
 */
const SearchInput = /*#__PURE__*/forwardRef(function SearchInput({
  className = '',
  classNames = {},
  onBlur,
  onChange,
  onClear,
  onFocus,
  onKeyDown,
  style = {},
  styles = {},
  value,
  ...consumerProps
}, forwardedRef) {
  // Refs and state
  const {
    isDisabled
  } = useFieldContext();
  const internalRef = useRef(null);
  const [inputValue, setInputValue] = useState(value);

  // Determine if the input is controlled or not
  const isControlled = value !== undefined;
  const clearInput = useCallback(() => {
    setInputValue('');
    if (onClear) onClear();
  }, [onClear]);
  const handleKeyDown = useCallback(event => {
    // Clears the input when the escape key is pressed and input is not "disabled"
    if (!isDisabled && event.key === 'Escape') {
      clearInput();
    }
    if (onKeyDown) onKeyDown(event);
  }, [clearInput, isDisabled, onKeyDown]);

  // Event handlers
  function handleChange(event) {
    // Update internal state
    setInputValue(event.target.value);

    // Call onChange callback if provided
    if (onChange) onChange(event);
  }
  function handleBlur(event) {
    if (onBlur) onBlur(event);
  }
  function handleFocus(event) {
    if (onFocus) onFocus(event);
  }

  // Set state during render to avoid using an effect
  if (isControlled && value !== inputValue) {
    setInputValue(value);
  }

  // Styling
  const {
    size
  } = useFieldContext();
  const styleProps = getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getSearchInputStyles({
      size,
      isDisabled
    })
  });
  const searchAdornment = /*#__PURE__*/jsx(ClickableAdornment, {
    ...styleProps('adornmentStart'),
    children: /*#__PURE__*/jsx(SearchIcon, {
      size: buttonSizeToIconSize[size]
    })
  });
  const shouldRenderClearAdornment = useMemo(() => {
    // Check if inputValue is not empty
    if (Boolean(inputValue)) {
      return isControlled ?
      // For controlled inputs, additionally check if onClear is provided
      Boolean(onClear) :
      // For uncontrolled inputs, always render the clear adornment
      true;
    }
    // If inputValue is empty, don't render the clear adornment
    return false;
  }, [inputValue, isControlled, onClear]);
  const clearAdornment = shouldRenderClearAdornment ? /*#__PURE__*/jsx(ClickableAdornment, {
    ...styleProps('adornmentEnd'),
    onClick: isDisabled ? undefined : clearInput,
    children: /*#__PURE__*/jsx(RemoveIcon, {
      size: buttonSizeToIconSize[size]
    })
  }) : null;
  return /*#__PURE__*/jsx(TextInput, {
    ...consumerProps,
    adornmentEnd: clearAdornment,
    adornmentStart: searchAdornment,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    ref: mergeRefs(internalRef, forwardedRef),
    value: inputValue,
    ...styleProps('root')
  });
});
SearchInput.displayName = 'SearchInput';

export { SearchInput };
