'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var jsxRuntime = require('react/jsx-runtime');
var parseImageProcessingOptions = require('./parse-image-processing-options-c3eac627.cjs.dev.js');
var sendFormDataRequest = require('./send-form-data-request-29c8bff0.cjs.dev.js');
var edsCore = require('@adaptavant/eds-core');
var clsx = require('clsx');
var experimental = require('@adaptavant/eds-core/experimental');
var cx = require('./cx-26784cbb.cjs.dev.js');
var upload_file_button = require('./upload-file-button-936dd2dc.cjs.dev.js');
var use_state_ref = require('./use-state-ref-f7a866e1.cjs.dev.js');
var cropper_component = require('./cropper-component-86a3fdfb.cjs.dev.js');
var use_deep_compare_memoize = require('./use-deep-compare-memoize-de2987aa.cjs.dev.js');
var use_viewport_below_or_equal = require('./use-viewport-below-or-equal-a63c017b.cjs.dev.js');
var use_state_manager = require('./use-state-manager-4d162c0b.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var clsx__default = /*#__PURE__*/_interopDefault(clsx);

const getEntries = obj => Object.entries(obj);

const normalizeObjectNumbers = (object, decimals) => getEntries(object).reduce((accumulator, [key, value]) => {
  if (typeof value === 'number') {
    accumulator[key] = sendFormDataRequest.roundNumberToDecimal(value, decimals);
  }
  return accumulator;
}, object);

const calculateCropDimensions = (cropBoxData, canvasData) => {
  const scaleX = canvasData.naturalWidth / canvasData.width;
  const scaleY = canvasData.naturalHeight / canvasData.height;
  const width = cropBoxData.width * scaleX;
  const height = cropBoxData.height * scaleY;
  const left = (cropBoxData.left - canvasData.left) * scaleX;
  const top = (cropBoxData.top - canvasData.top) * scaleY;
  return normalizeObjectNumbers({
    width,
    height,
    left,
    top
  }, 0);
};

const fetchGoogleStorageUploadUrl = async (url, accessToken) => {
  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  return response.json();
};

const fetchInitialImageUrl = async url => {
  const response = await fetch(url);
  return response.blob();
};

const DEFAULT_API_OPTIONS = {
  uploadUrl: 'UNKNOWN',
  sendFormDataRequest: sendFormDataRequest.sendFormDataRequest,
  fetchInitialImageUrl,
  fetchGoogleStorageUploadUrl,
  getAccessToken: () => Promise.resolve('UNKNOWN')
};
const parseApiOptions = options => ({
  ...DEFAULT_API_OPTIONS,
  ...options
});

const parseAspectRatio = (aspectRatio, isCircle) => {
  if (isCircle) {
    return 1;
  }
  return sendFormDataRequest.clamp(aspectRatio ?? 1, 1 / 20, 20 / 1);
};
const formatNumber = (number, max) => {
  const roundedNumber = sendFormDataRequest.roundNumberToDecimal(number, 0);
  const clampedNumber = sendFormDataRequest.clamp(roundedNumber, 0, max);
  return clampedNumber % 2 === 0 ? clampedNumber : clampedNumber + 1;
};
const parseCropViewBoxOptions = (cropViewBox, generalOptions) => {
  const aspectRatio = parseAspectRatio(cropViewBox.aspectRatio, cropViewBox.isCircle);
  const width = formatNumber(cropViewBox.width, generalOptions.canvasWidth);
  const height = formatNumber(width / aspectRatio, generalOptions.canvasHeight);
  return {
    ...cropViewBox,
    width,
    height,
    aspectRatio
  };
};

const DEFAULT_GENERAL_OPTIONS = {
  canvasWidth: 500,
  canvasHeight: 300,
  maxScaleFactor: 5,
  totalSidePadding: 48,
  hideZoomSliderOnMobile: true,
  saveButtonVariant: 'accentPrimary'
};
const parseGeneralOptions = (generalOptions = {}, screenWidth) => {
  const unprocessedOutput = {
    ...DEFAULT_GENERAL_OPTIONS,
    ...generalOptions
  };
  return {
    ...unprocessedOutput,
    canvasWidth: Math.min(unprocessedOutput.canvasWidth, screenWidth - unprocessedOutput.totalSidePadding),
    unprocessedCanvasWidth: unprocessedOutput.canvasWidth
  };
};

const calculateInitialZoom = ({
  cropHeight,
  cropWidth,
  maxScaleFactor,
  naturalHeight,
  naturalWidth
}) => {
  const widthRatio = cropWidth / naturalWidth;
  const heightRatio = cropHeight / naturalHeight;
  const minZoom = Math.max(widthRatio, heightRatio);
  const maxZoom = minZoom * maxScaleFactor;
  return normalizeObjectNumbers({
    minZoom,
    maxZoom
  }, 3);
};

const cropDimensionsToCanvasData = (cropDimensions, cropBoxData) => {
  const scale = cropBoxData.width / cropDimensions.width;
  const top = cropBoxData.top - cropDimensions.top * scale;
  const left = cropBoxData.left - cropDimensions.left * scale;
  return normalizeObjectNumbers({
    top,
    left,
    scale
  }, 2);
};

const setCropBoxDimensions = (cropperInstance, minZoom, canvasWidth, canvasHeight, cropWidth, cropHeight) => {
  cropperInstance.zoomTo(minZoom).setCropBoxData({
    width: cropWidth,
    height: cropHeight,
    left: (canvasWidth - cropWidth) / 2,
    top: (canvasHeight - cropHeight) / 2
  }).zoomTo(minZoom);
};
const centerCanvasPosition = (cropperInstance, canvasWidth, canvasHeight, cropWidth, cropHeight) => {
  const prevCanvasData = cropperInstance.getCanvasData();
  cropperInstance.setCanvasData({
    ...prevCanvasData,
    left: canvasWidth / 2 - cropWidth / 2 - (prevCanvasData.width - cropWidth) / 2,
    top: canvasHeight / 2 - cropHeight / 2 - (prevCanvasData.height - cropHeight) / 2
  });
};
const applyCropDimensionsAndZoom = (cropperInstance, cropDimensions, minZoom, maxZoom, setZoom) => {
  if (cropDimensions) {
    const canvasData = cropDimensionsToCanvasData(cropDimensions, cropperInstance.getCropBoxData());
    const correctedScale = sendFormDataRequest.clamp(canvasData.scale, minZoom, maxZoom);
    setZoom(correctedScale);
    cropperInstance.zoomTo(correctedScale);
    cropperInstance.moveTo(canvasData.left, canvasData.top);
  }
};
const setupCropperArea = ({
  canvasHeight,
  canvasWidth,
  cropDimensions,
  cropHeight,
  cropperInstance,
  cropWidth,
  maxScaleFactor,
  setZoom,
  setMinZoom
}) => {
  const {
    maxZoom,
    minZoom
  } = calculateInitialZoom({
    ...cropperInstance.getCanvasData(),
    cropWidth,
    cropHeight,
    maxScaleFactor
  });
  setMinZoom(minZoom);
  setZoom(minZoom);
  setCropBoxDimensions(cropperInstance, minZoom, canvasWidth, canvasHeight, cropWidth, cropHeight);
  centerCanvasPosition(cropperInstance, canvasWidth, canvasHeight, cropWidth, cropHeight);
  applyCropDimensionsAndZoom(cropperInstance, cropDimensions, minZoom, maxZoom, setZoom);
};

// TODO: Add to EDS core icons package
const ZoomOutIcon = ({
  className
}) => /*#__PURE__*/jsxRuntime.jsxs("svg", {
  className: clsx.clsx('h-4 w-4', className),
  fill: "none",
  height: 16,
  viewBox: "0 0 17 16",
  width: 16,
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsxRuntime.jsx("path", {
    d: "m11.167 8h-5.3333",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.2"
  }), /*#__PURE__*/jsxRuntime.jsx("path", {
    clipRule: "evenodd",
    d: "m8.5 14v0c-3.314 0-6-2.686-6-6v0c0-3.314 2.686-6 6-6v0c3.314 0 6 2.686 6 6v0c0 3.314-2.686 6-6 6z",
    fillRule: "evenodd",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.2"
  })]
});
ZoomOutIcon.displayName = 'ZoomOutIcon';

const IconButtonWithTooltip = ({
  'aria-label': ariaLabel,
  content,
  icon,
  isDisabled,
  onClick,
  dataTestId
}) => !!content && !isDisabled ? /*#__PURE__*/jsxRuntime.jsx(edsCore.Tooltip, {
  content: content,
  placement: "bottom",
  shouldUsePortal: false,
  children: ({
    triggerProps
  }) => /*#__PURE__*/jsxRuntime.jsx(edsCore.IconButton, {
    "aria-label": ariaLabel,
    className: "h-6 min-w-6",
    "data-testid": dataTestId,
    icon: icon,
    onClick: onClick,
    size: "small",
    type: "button",
    variant: "neutralTertiary",
    ...triggerProps
  })
}) : /*#__PURE__*/jsxRuntime.jsx(edsCore.IconButton, {
  "aria-label": ariaLabel,
  className: "h-6 min-w-6",
  "data-testid": dataTestId,
  icon: icon,
  isDisabled: isDisabled,
  onClick: onClick,
  size: "small",
  type: "button",
  variant: "neutralTertiary"
});

const CropArea = ({
  allowedMimeType,
  aspectRatio,
  canvasHeight,
  canvasWidth,
  cropDimensions,
  cropHeight,
  cropWidth,
  imageUrl,
  isCircleViewBox,
  isNewlyUploadedImageProcessing,
  maxScaleFactor,
  onCropEnd,
  onFilesChange,
  onZoomChange,
  translations,
  isResponsiveViewport,
  hideZoomSliderOnMobile
}) => {
  const cropperRef = React.useRef(null);
  const cropDimensionsRef = React.useRef(cropDimensions);
  const [zoom, setZoom] = React.useState();
  const [minZoom, setMinZoom, minZoomRef] = use_state_ref.useStateRef();
  const maxZoom = React.useMemo(() => minZoom && sendFormDataRequest.roundNumberToDecimal(minZoom * maxScaleFactor, 3), [maxScaleFactor, minZoom]);
  const zoomSteps = React.useMemo(() => {
    const step = sendFormDataRequest.roundNumberToDecimal(canvasWidth / 10_000, 3);
    return {
      in: step,
      out: -step
    };
  }, [canvasWidth]);
  React.useEffect(() => {
    cropDimensionsRef.current = cropDimensions;
  }, [cropDimensions]);
  const handleUpdateZoom = React.useCallback((newZoom, updateCropperInstance = true) => {
    var _cropperRef$current;
    const cropperInstance = (_cropperRef$current = cropperRef.current) === null || _cropperRef$current === void 0 ? void 0 : _cropperRef$current.cropper;
    if (cropperInstance) {
      if (updateCropperInstance) {
        cropperInstance.zoomTo(newZoom);
      }
      setZoom(newZoom);
      onZoomChange(cropperInstance);
    }
  }, [onZoomChange]);
  const handleReady = React.useCallback(() => {
    var _cropperRef$current2;
    const cropperInstance = (_cropperRef$current2 = cropperRef.current) === null || _cropperRef$current2 === void 0 ? void 0 : _cropperRef$current2.cropper;
    if (cropperInstance) {
      setupCropperArea({
        setZoom,
        cropWidth,
        cropHeight,
        setMinZoom,
        canvasWidth,
        canvasHeight,
        maxScaleFactor,
        cropperInstance,
        cropDimensions: cropDimensionsRef.current
      });
      onZoomChange(cropperInstance);
    }
  }, [cropWidth, cropHeight, canvasWidth, canvasHeight, maxScaleFactor, onZoomChange, setMinZoom]);
  const handleCropEnd = React.useCallback(() => {
    var _cropperRef$current3;
    const cropperInstance = (_cropperRef$current3 = cropperRef.current) === null || _cropperRef$current3 === void 0 ? void 0 : _cropperRef$current3.cropper;
    if (cropperInstance) {
      onCropEnd(cropperInstance);
    }
  }, [onCropEnd]);
  const handleSliderChange = React.useCallback(newValue => {
    if (zoom === undefined || minZoom === undefined || maxZoom === undefined) return;
    const newZoom = sendFormDataRequest.roundNumberToDecimal(newValue, 3);
    handleUpdateZoom(sendFormDataRequest.clamp(newZoom, minZoom, maxZoom));
  }, [handleUpdateZoom, zoom, minZoom, maxZoom]);
  const handleZoomButtonClick = React.useCallback(direction => {
    if (zoom === undefined || minZoom === undefined || maxZoom === undefined) return;
    const newZoom = sendFormDataRequest.roundNumberToDecimal(zoom + zoomSteps[direction], 3);
    handleUpdateZoom(sendFormDataRequest.clamp(newZoom, minZoom, maxZoom));
  }, [zoom, minZoom, maxZoom, handleUpdateZoom, zoomSteps]);
  const handleZoomInButtonClick = React.useCallback(() => handleZoomButtonClick('in'), [handleZoomButtonClick]);
  const handleZoomOutButtonClick = React.useCallback(() => handleZoomButtonClick('out'), [handleZoomButtonClick]);
  const handleTouchZoomChange = event => {
    if (minZoomRef.current === undefined) {
      return;
    }
    const {
      ratio
    } = event.detail;
    const clampedZoom = sendFormDataRequest.clamp(ratio, minZoomRef.current, minZoomRef.current * maxScaleFactor);
    const isOutOfBound = clampedZoom !== ratio;
    if (isOutOfBound) {
      event.preventDefault();
    }
    handleUpdateZoom(sendFormDataRequest.roundNumberToDecimal(clampedZoom, 3), isOutOfBound);
  };
  return /*#__PURE__*/jsxRuntime.jsx(edsCore.Track, {
    className: "flex-col",
    classNames: {
      railEnd: 'w-full'
    },
    "data-testid": "crop-modal--crop-area",
    railEnd: isResponsiveViewport && hideZoomSliderOnMobile ? null : /*#__PURE__*/jsxRuntime.jsxs(edsCore.Box, {
      className: cx.cx('flex items-center justify-center gap-8 w-full', isResponsiveViewport ? 'border-none pb-0 pt-9' : 'border-tertiary border-b-[1px] border-solid py-6'),
      children: [/*#__PURE__*/jsxRuntime.jsxs(edsCore.Box, {
        className: "flex w-48 flex-col items-center",
        children: [/*#__PURE__*/jsxRuntime.jsx(edsCore.Label, {
          className: "sr-only",
          id: "zoom-slider-label",
          children: "Zoom slider"
        }), zoom !== undefined && minZoom !== undefined && maxZoom !== undefined ? /*#__PURE__*/jsxRuntime.jsx(experimental.Slider, {
          adornmentEnd: /*#__PURE__*/jsxRuntime.jsx(IconButtonWithTooltip, {
            "aria-label": (translations === null || translations === void 0 ? void 0 : translations.zoomInButtonLabel) ?? edsCore.AddOnIcon.displayName ?? '',
            content: translations === null || translations === void 0 ? void 0 : translations.zoomInButtonLabel,
            dataTestId: "crop-modal--crop-area--zoom-in-button",
            icon: edsCore.AddOnIcon,
            isDisabled: zoom >= maxZoom,
            onClick: handleZoomInButtonClick
          }),
          adornmentStart: /*#__PURE__*/jsxRuntime.jsx(IconButtonWithTooltip, {
            "aria-label": (translations === null || translations === void 0 ? void 0 : translations.zoomOutButtonLabel) ?? ZoomOutIcon.displayName ?? '',
            content: translations === null || translations === void 0 ? void 0 : translations.zoomOutButtonLabel,
            dataTestId: "crop-modal--crop-area--zoom-out-button",
            icon: ZoomOutIcon,
            isDisabled: zoom <= minZoom,
            onClick: handleZoomOutButtonClick
          }),
          ariaLabelledBy: "zoom-slider-label",
          className: "gap-4",
          "data-testid": "crop-modal--crop-area--zoom-slider",
          maxValue: maxZoom,
          minValue: minZoom,
          onValueChange: handleSliderChange,
          step: 0.001,
          value: sendFormDataRequest.clamp(zoom, minZoom, maxZoom)
        }) : null]
      }), !isResponsiveViewport && translations !== null && translations !== void 0 && translations.uploadNewButtonLabel ? /*#__PURE__*/jsxRuntime.jsx(upload_file_button.UploadFileButton, {
        accept: allowedMimeType,
        onFilesChange: onFilesChange,
        children: /*#__PURE__*/jsxRuntime.jsx(edsCore.Button, {
          "data-testid": "crop-modal--crop-area--upload-button",
          iconStart: edsCore.ImageIcon,
          isLoading: isNewlyUploadedImageProcessing,
          size: "standard",
          variant: "neutralSecondary",
          children: translations.uploadNewButtonLabel
        })
      }) : null]
    }),
    style: {
      width: canvasWidth
    },
    children: /*#__PURE__*/jsxRuntime.jsx(cropper_component.CropperComponent, {
      autoCropArea: 1,
      cropBoxMovable: false,
      cropBoxResizable: false,
      cropend: handleCropEnd,
      dragMode: "move",
      guides: false,
      initialAspectRatio: aspectRatio,
      isCircleViewBox: isCircleViewBox,
      ready: handleReady,
      ref: cropperRef,
      restore: false,
      src: imageUrl ?? undefined,
      style: {
        height: canvasHeight,
        width: canvasWidth
      },
      toggleDragModeOnDblclick: false,
      viewMode: 1,
      zoom: handleTouchZoomChange,
      zoomOnTouch: true,
      zoomOnWheel: true
    })
  });
};

const DropArea = ({
  allowedMimeType,
  errorMessage,
  height,
  isLoading,
  onFilesChange,
  translations,
  width
}) => /*#__PURE__*/jsxRuntime.jsxs(edsCore.Box, {
  className: clsx__default["default"]('rounded-8px bg-canvas relative flex flex-col items-center justify-center border', {
    'pointer-events-none': isLoading,
    'border-secondary': !errorMessage,
    'border-input-critical': !!errorMessage
  }),
  "data-testid": "crop-modal--drop-area",
  style: {
    width,
    height,
    borderStyle: 'dashed'
  },
  children: [/*#__PURE__*/jsxRuntime.jsx(upload_file_button.UploadFileButton, {
    accept: allowedMimeType,
    onFilesChange: onFilesChange,
    children: /*#__PURE__*/jsxRuntime.jsx(edsCore.Button, {
      "data-testid": "crop-modal--drop-area--upload-button",
      iconStart: edsCore.ImageIcon,
      isDisabled: isLoading,
      isLoading: isLoading,
      size: "standard",
      variant: "accentSecondary",
      children: translations.uploadImageButtonLabel
    })
  }), errorMessage ? /*#__PURE__*/jsxRuntime.jsx(edsCore.FieldErrorMessage, {
    className: "mt-4",
    "data-testid": "crop-modal--drop-area--error-message",
    children: errorMessage
  }) : null, /*#__PURE__*/jsxRuntime.jsxs(edsCore.Text, {
    className: "text-body-12 absolute bottom-4 text-secondary",
    "data-testid": "crop-modal--drop-area--description",
    children: [translations.bottomTextPrefix, translations.bottomLinkText && translations.bottomLinkUrl ? /*#__PURE__*/jsxRuntime.jsx(edsCore.TextLink, {
      "data-testid": "crop-modal--drop-area--description--link",
      href: translations.bottomLinkUrl,
      rel: "noopener",
      target: "_blank",
      variant: "accentPrimary",
      children: translations.bottomLinkText
    }) : null, translations.bottomTextSuffix]
  })]
});

const LoaderArea = ({
  height,
  width
}) => /*#__PURE__*/jsxRuntime.jsx("div", {
  className: "flex items-center justify-center bg-canvas-secondary rounded-8px",
  "data-testid": "crop-modal--loader-area",
  style: {
    width,
    height
  },
  children: /*#__PURE__*/jsxRuntime.jsx(edsCore.Loading, {})
});

const TITLE_ID = 'crop-modal-title';
const DESCRIPTION_ID = 'crop-modal-description';
const ModalWrapper = ({
  canvasWidth,
  children,
  errorMessage,
  isCancelDisabled,
  isLoading,
  isOpen = false,
  isSaveDisabled,
  onCancel,
  onClose,
  onSave,
  saveButtonVariant,
  translations,
  classNames,
  totalSidePadding,
  isResponsiveViewport,
  unprocessedCanvasWidth
}) => {
  return isOpen ? /*#__PURE__*/jsxRuntime.jsxs(edsCore.Modal, {
    className: clsx.clsx('bg-canvas', {
      'gap-5': isResponsiveViewport,
      'gap-2': !isResponsiveViewport
    }),
    classNames: {
      modalWrapper: clsx.clsx('px-0 z-[1200]', {
        'py-4': !isResponsiveViewport,
        'py-0 items-end': isResponsiveViewport
      }, classNames === null || classNames === void 0 ? void 0 : classNames.modalWrapper)
    },
    closeOnEsc: !isLoading,
    closeOnOverlayClick: !isLoading,
    descriptionId: DESCRIPTION_ID,
    mobileFriendly: true,
    onClose: onClose,
    open: isOpen,
    role: "dialog",
    size: canvasWidth + totalSidePadding,
    titleId: TITLE_ID,
    togglePoint: unprocessedCanvasWidth + totalSidePadding,
    children: [/*#__PURE__*/jsxRuntime.jsx(edsCore.ModalHeader, {
      className: clsx.clsx('pr-6', {
        'pointer-events-none select-none': isLoading
      }),
      closeButtonProps: {
        onClick: onClose,
        label: translations.closeModalButtonLabel
      },
      children: /*#__PURE__*/jsxRuntime.jsx(edsCore.Heading, {
        as: "h3",
        className: "text-heading-16 font-stronger",
        "data-testid": "crop-modal--title",
        id: TITLE_ID,
        children: isResponsiveViewport ? null : translations.title
      })
    }), /*#__PURE__*/jsxRuntime.jsxs(edsCore.ModalContent, {
      className: clsx.clsx('overflow-hidden', {
        'pointer-events-none select-none': isLoading
      }),
      children: [/*#__PURE__*/jsxRuntime.jsx(edsCore.Text, {
        className: "text-body-12 mb-4 text-secondary",
        "data-testid": "crop-modal--subtitle",
        id: DESCRIPTION_ID,
        children: isResponsiveViewport ? null : translations.subtitle
      }), children]
    }), /*#__PURE__*/jsxRuntime.jsxs(edsCore.ModalFooter, {
      className: clsx.clsx('pt-4', {
        'pointer-events-none select-none': isLoading,
        'flex flex-col pb-3': isResponsiveViewport
      }),
      children: [errorMessage ? /*#__PURE__*/jsxRuntime.jsx(edsCore.FieldErrorMessage, {
        className: "mr-auto",
        classNames: {
          errorMessage: clsx.clsx({
            'text-body-14': isResponsiveViewport
          })
        },
        "data-testid": "crop-modal--error-message",
        children: errorMessage
      }) : null, isResponsiveViewport ? null : /*#__PURE__*/jsxRuntime.jsx(edsCore.Button, {
        "data-testid": "crop-modal--cancel-button",
        isDisabled: isCancelDisabled,
        onClick: onCancel,
        variant: "neutralTertiary",
        children: translations.cancelButtonLabel
      }), /*#__PURE__*/jsxRuntime.jsx(edsCore.Button, {
        className: clsx.clsx({
          'w-full': isResponsiveViewport
        }),
        "data-testid": "crop-modal--save-button",
        isDisabled: isSaveDisabled,
        isLoading: isLoading,
        onClick: onSave,
        size: isResponsiveViewport ? 'large' : 'standard',
        variant: saveButtonVariant,
        children: translations.saveButtonLabel
      })]
    })]
  }) : null;
};

const CropModal = ({
  apiOptions,
  cropAreaTranslations,
  cropViewBoxOptions,
  dropAreaTranslations,
  errorTranslations,
  generalOptions,
  imageProcessingOptions,
  imageUrl,
  isOpen,
  classNames,
  modalWrapperTranslations,
  onCancel,
  onClose,
  onError,
  onSuccessfulUpload
}) => {
  const screenWidth = typeof window !== 'undefined' ? window.innerWidth : 0;
  const parsedErrorTranslations = use_deep_compare_memoize.useDeepCompareMemo(() => parseImageProcessingOptions.parseErrorTranslations(errorTranslations), [errorTranslations]);
  const parsedApiOptions = use_deep_compare_memoize.useDeepCompareMemo(() => parseApiOptions(apiOptions), [apiOptions]);
  const parsedGeneralOptions = use_deep_compare_memoize.useDeepCompareMemo(() => parseGeneralOptions(generalOptions, screenWidth), [generalOptions, screenWidth]);
  const parsedCropViewBoxOptions = use_deep_compare_memoize.useDeepCompareMemo(() => parseCropViewBoxOptions(cropViewBoxOptions, parsedGeneralOptions), [cropViewBoxOptions, parsedGeneralOptions]);
  const parsedImageProcessingOptions = use_deep_compare_memoize.useDeepCompareMemo(() => parseImageProcessingOptions.parseImageProcessingOptions(imageProcessingOptions), [imageProcessingOptions]);
  const isResponsiveViewport = use_viewport_below_or_equal.useIsViewportBelowOrEqual(parsedGeneralOptions.unprocessedCanvasWidth + parsedGeneralOptions.totalSidePadding);
  const {
    isSaving,
    errorMessage,
    imageMetadata,
    isLoadingRemoteImage,
    isProcessingLocalFile,
    saveChanges,
    resetOnClose,
    processLocalImage,
    updateCropDimensions
  } = use_state_manager.useStateManager({
    imageUrl,
    onError,
    onSuccessfulUpload,
    apiOptions: parsedApiOptions,
    translations: parsedErrorTranslations,
    imageProcessingOptions: parsedImageProcessingOptions
  });
  const handleClose = React.useCallback(() => {
    resetOnClose();
    onClose();
  }, [onClose, resetOnClose]);
  const handleCancel = React.useCallback(() => {
    resetOnClose();
    onCancel();
  }, [onCancel, resetOnClose]);
  const handleCropAreaChange = React.useCallback(cropperInstance => {
    const cropData = cropperInstance.getCropBoxData();
    const canvasData = cropperInstance.getCanvasData();
    const cropDimensions = calculateCropDimensions(cropData, canvasData);
    updateCropDimensions(cropDimensions);
  }, [updateCropDimensions]);
  const handleFilesChange = React.useCallback(files => {
    if (files[0]) {
      processLocalImage(files[0]);
    }
  }, [processLocalImage]);
  const hasOriginalOrUploadedFile = !!imageMetadata.originalBlob || !!imageMetadata.processedBlob;
  const showLoadingArea = isLoadingRemoteImage && !hasOriginalOrUploadedFile;
  const showCropArea = !showLoadingArea && hasOriginalOrUploadedFile;
  return /*#__PURE__*/jsxRuntime.jsxs(ModalWrapper, {
    canvasWidth: parsedGeneralOptions.canvasWidth,
    classNames: classNames,
    errorMessage: showCropArea ? errorMessage : undefined,
    isCancelDisabled: isSaving || isProcessingLocalFile,
    isLoading: isSaving || isProcessingLocalFile,
    isOpen: isOpen,
    isResponsiveViewport: isResponsiveViewport,
    isSaveDisabled: !imageMetadata.isNewlyUploaded && !imageMetadata.hasCropChanged || !hasOriginalOrUploadedFile && !!errorMessage,
    onCancel: handleCancel,
    onClose: handleClose,
    onSave: saveChanges,
    saveButtonVariant: parsedGeneralOptions.saveButtonVariant,
    totalSidePadding: parsedGeneralOptions.totalSidePadding,
    translations: modalWrapperTranslations,
    unprocessedCanvasWidth: parsedGeneralOptions.unprocessedCanvasWidth,
    children: [showLoadingArea ? /*#__PURE__*/jsxRuntime.jsx(LoaderArea, {
      height: parsedGeneralOptions.canvasHeight,
      width: parsedGeneralOptions.canvasWidth
    }) : null, showCropArea ? /*#__PURE__*/jsxRuntime.jsx(CropArea, {
      allowedMimeType: parsedImageProcessingOptions.allowedMimeType,
      aspectRatio: parsedCropViewBoxOptions.aspectRatio,
      canvasHeight: parsedGeneralOptions.canvasHeight,
      canvasWidth: parsedGeneralOptions.canvasWidth,
      cropDimensions: imageMetadata.isNewlyUploaded ? null : imageMetadata.originalCropDimensions,
      cropHeight: parsedCropViewBoxOptions.height,
      cropWidth: parsedCropViewBoxOptions.width,
      hideZoomSliderOnMobile: parsedGeneralOptions.hideZoomSliderOnMobile,
      imageUrl: imageMetadata.isNewlyUploaded ? imageMetadata.processedBlobUrl : imageMetadata.originalBlobUrl,
      isCircleViewBox: parsedCropViewBoxOptions.isCircle,
      isNewlyUploadedImageProcessing: isProcessingLocalFile,
      isResponsiveViewport: isResponsiveViewport,
      maxScaleFactor: parsedGeneralOptions.maxScaleFactor,
      onCropEnd: handleCropAreaChange,
      onFilesChange: handleFilesChange,
      onZoomChange: handleCropAreaChange,
      translations: cropAreaTranslations
    }) : null, showCropArea || !dropAreaTranslations ? null : /*#__PURE__*/jsxRuntime.jsx(DropArea, {
      allowedMimeType: parsedImageProcessingOptions.allowedMimeType,
      errorMessage: errorMessage,
      height: parsedGeneralOptions.canvasHeight,
      isLoading: isProcessingLocalFile,
      onFilesChange: handleFilesChange,
      translations: dropAreaTranslations,
      width: parsedGeneralOptions.canvasWidth
    })]
  });
};

exports.CropModal = CropModal;
