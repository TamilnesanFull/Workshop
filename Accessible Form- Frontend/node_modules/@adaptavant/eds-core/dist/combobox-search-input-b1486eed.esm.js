'use client';
import { isAppleDevice } from '@react-aria/utils';
import { assertNever } from 'emery';
import { forwardRef, useCallback, Fragment, useMemo, useState, useEffect } from 'react';
import { useDropdownContext } from './context-6e374e37.esm.js';
import { i as isNodeListOfHTMLElements } from './utils-0956ef0f.esm.js';
import { m as mergeProps } from './merge-props-5c13cba9.esm.js';
import { useCombobox } from './context-a9b03758.esm.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { B as Box } from './box-a5dda214.esm.js';
import { SearchInput } from './search-input-c957feb3.esm.js';
import { useFieldContext } from './context-2a1498a6.esm.js';
import './cx-c5d68be6.esm.js';
import 'clsx';
import './merge-ids-c2d2d3d7.esm.js';
import './index-dd10a77e.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';

const ComboboxSearchInput = /*#__PURE__*/forwardRef(function ComboboxSearchInput(props, forwardedRef) {
  const {
    inputProps
  } = useComboboxSearchInput(props);
  const {
    onClear,
    onSelectionChange
  } = useCombobox();
  const {
    clearSelectedItem
  } = useDropdownContext();
  const handleOnClear = useCallback(() => {
    if (typeof onClear === 'function') {
      onClear();
    }
    clearSelectedItem();
    onSelectionChange(undefined);
  }, [clearSelectedItem, onClear, onSelectionChange]);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(SearchInput, {
      ...inputProps,
      onClear: handleOnClear,
      ref: forwardedRef
    }), /*#__PURE__*/jsx(LiveRegion, {})]
  });
});
ComboboxSearchInput.displayName = 'ComboboxSearchInput';
function useComboboxSearchInput(props) {
  const {
    inputValue = '',
    // Set inputValue to an empty string to prevent uncontrolled to controlled input warning. More info: https://reactjs.org/link/uncontrolled-to-controlled
    menuTrigger,
    onInputChange,
    onSelectionChange
  } = useCombobox();
  const {
    activeDescendantId,
    isMenuOpen,
    listId,
    popover,
    openMenu,
    clearSelectedItem
  } = useDropdownContext();
  const {
    isDisabled
  } = useFieldContext();
  const handleChange = useCallback(event => {
    if (!isMenuOpen) openMenu();
    if (onInputChange) onInputChange(event.target.value);
    if (event.target.value === '') {
      clearSelectedItem();
      if (onSelectionChange) {
        onSelectionChange(undefined);
      }
    }
  }, [clearSelectedItem, isMenuOpen, onInputChange, onSelectionChange, openMenu]);
  const handleFocus = useCallback(() => {
    if (menuTrigger === 'focus') openMenu();
  }, [menuTrigger, openMenu]);
  const referenceProps = popover.getReferenceProps();
  const handleKeyDown = useKeydownNavigation();
  const isAppleDevice$1 = isAppleDevice();
  const a11yProps = useMemo(() => ({
    'aria-activedescendant': isAppleDevice$1 ? undefined : activeDescendantId,
    'aria-autocomplete': 'list',
    'aria-controls': listId,
    'aria-expanded': isMenuOpen,
    'aria-haspopup': 'listbox',
    autoComplete: 'off',
    autoCorrect: 'off',
    spellCheck: 'false',
    role: 'combobox'
  }), [activeDescendantId, isAppleDevice$1, isMenuOpen, listId]);
  const comboboxProps = useMemo(() => ({
    onKeyDown: isDisabled ? undefined : handleKeyDown,
    onChange: handleChange,
    onFocus: isDisabled ? undefined : handleFocus,
    value: inputValue
  }), [isDisabled, handleKeyDown, handleChange, handleFocus, inputValue]);
  return {
    inputProps: useMemo(() => ({
      ...mergeProps(props, a11yProps, comboboxProps),
      focusContainerRef: referenceProps.ref
    }), [props, a11yProps, comboboxProps, referenceProps.ref])
  };
}

/**
 * On desktop Safari with VoiceOver, the aria-activedescendant
 * attribute seems to be ignored so we have set up a aria-live region
 * to fake it.
 * However, older versions of VoiceOver of Safari for iOS it ignores
 * the aria-live region and only announces the aria-activedescendant
 * so we need to use both.
 */
function LiveRegion() {
  const isAppleDevice$1 = isAppleDevice();
  const {
    activeDescendantId,
    activeDescendantIndex,
    descendantCount,
    descendantNodes,
    selectedOptionId
  } = useDropdownContext();
  const [activeDescendantText, setActiveDescendantText] = useState(null);
  useEffect(() => {
    // get the text content of the active descendant
    if (activeDescendantIndex === -1 || !isNodeListOfHTMLElements(descendantNodes)) {
      return undefined;
    }
    const activeDescendant = descendantNodes[activeDescendantIndex];
    if (activeDescendant && activeDescendant.textContent) {
      setActiveDescendantText(activeDescendant.textContent
      // Remove whitespace and zero-width space characters
      .replace(/[\s\u200B]+/g, ' ').trim());
    }
  }, [activeDescendantIndex, descendantNodes]);
  if (!isAppleDevice$1 || descendantCount <= 0 || activeDescendantIndex > descendantCount) {
    return null;
  }
  const isSelected = activeDescendantId === selectedOptionId;
  const selectionStatus = isSelected ? 'Selected' : '';
  const positionInfo = `${activeDescendantIndex + 1} of ${descendantCount}`;
  const liveRegionText = activeDescendantText ? [activeDescendantText, selectionStatus, positionInfo].filter(Boolean).join('. ') : null;
  return /*#__PURE__*/jsx(Box, {
    "aria-live": "assertive",
    className: "sr-only",
    children: liveRegionText
  });
}
const supportedKeys = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'Escape', 'Enter', 'Tab'];
function isSupportedKey(key) {
  return supportedKeys.includes(key);
}
function useKeydownNavigation(onEnterInputHandler) {
  const {
    clickSelectedItem,
    closeMenu,
    descendantNodes,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem,
    isMenuOpen,
    openMenu
  } = useDropdownContext();

  // We need a useEffect to focus the first or last item after the menu opens
  // because we need to wait for the descendantNodes to be created and set (see usePopulateDescendantNodes).
  const [focusItemAfterOpen, setFocusItemAfterOpen] = useState();
  useEffect(() => {
    if (!isMenuOpen || !descendantNodes || !focusItemAfterOpen) return;
    if (focusItemAfterOpen === 'first') {
      goToFirstMenuItem();
    }
    if (focusItemAfterOpen === 'last') {
      goToLastMenuItem();
    }
    setFocusItemAfterOpen(undefined);
  }, [isMenuOpen, descendantNodes, focusItemAfterOpen, goToFirstMenuItem, goToLastMenuItem]);
  return useCallback(event => {
    // If we don't have a case for the key, we can return early.
    if (!isSupportedKey(event.code)) return;
    switch (event.code) {
      case 'ArrowUp':
        {
          event.preventDefault();
          if (isMenuOpen) {
            goToPreviousMenuItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('last');
          }
          return;
        }
      case 'ArrowDown':
        {
          event.preventDefault();
          if (isMenuOpen) {
            goToNextMenuItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('first');
          }
          return;
        }
      case 'Home':
        {
          event.preventDefault();
          goToFirstMenuItem();
          return;
        }
      case 'End':
        {
          event.preventDefault();
          goToLastMenuItem();
          return;
        }
      case 'Escape':
        {
          closeMenu();
          return;
        }
      case 'Enter':
        {
          event.preventDefault();
          if (isMenuOpen) {
            clickSelectedItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('first');
          }
          if (onEnterInputHandler && typeof onEnterInputHandler === 'function') {
            onEnterInputHandler();
          }
          return;
        }
      case 'Tab':
        {
          closeMenu();
          return;
        }
      default:
        assertNever(event.code);
    }
  }, [clickSelectedItem, closeMenu, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem, isMenuOpen, onEnterInputHandler, openMenu]);
}

export { ComboboxSearchInput, LiveRegion, useComboboxSearchInput, useKeydownNavigation };
