'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('./index-7955fb8e.cjs.prod.js');
var twMerge = require('./tw-merge-885aa7a8.cjs.prod.js');
var mergeProps = require('./merge-props-60701ce8.cjs.prod.js');
var tw = require('./tw-9929267e.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var box = require('./box-e39057bd.cjs.prod.js');
var text = require('./text-a5ab226e.cjs.prod.js');
var label = require('./label-f7aa50fa.cjs.prod.js');
var radioPrimitive = require('./radio-primitive-ee368a35.cjs.prod.js');
var focus_container = require('./focus-container-be948f3e.cjs.prod.js');
var checkbox_primitive = require('./checkbox-primitive-aa61ad47.cjs.prod.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.prod.js');
require('@react-aria/utils');
require('./cx-86353291.cjs.prod.js');
require('clsx');
require('./merge-ids-2d47bd24.cjs.prod.js');
require('./styles-3786e407.cjs.prod.js');
require('./radio-control-icon-d55ee72d.cjs.prod.js');
require('./styles-30814c9d.cjs.prod.js');
require('./align-child-to-text-c75908d4.cjs.prod.js');

const getSelectCardStyles = ({
  isDisabled,
  orientation
}) => ({
  root: tw.tw`
		${orientation === 'vertical' ? 'flex-col' : 'flex-row'}
		${selectCardVerticalSpaceClasses.gap}
		flex
		flex-wrap
	`,
  legend: tw.tw`
		${isDisabled ? 'text-disabled' : ''}
		${selectCardVerticalSpaceClasses.marginBottom}
		sm:text-body-14
		text-body-16
	`,
  controlWrapper: tw.tw`
		shrink-0
	`,
  directContentWrapper: tw.tw`
		${orientation === 'vertical' ? 'flex-row justify-between' : 'flex-col justify-center'}
		flex
		gap-1
		grow
		h-full
		items-center
	`,
  dynamicContentWrapper: tw.tw`
		duration-300
		mb-2
		overflow-hidden
		pe-2
		ps-8 #1
		transition-[height]
	`
  // #1 - 32px is derived from: 8px padding of the cardRow + 8px gap between control input to direct content + 16px size of input
});
const getCardStyles = ({
  isDisabled,
  orientation
}) => ({
  card: tw.tw`
		${isDisabled ? 'text-disabled bg-neutral-disabled' : ''}
		min-h-9
		min-w-[154px]
		items-start
	`,
  cardRow: tw.tw`
		${isDisabled ? 'cursor-default' : 'cursor-pointer'}
		${orientation === 'vertical' ? 'items-center' : 'items-start'}
		flex
		gap-2
		p-2
	`,
  focusIndicator: tw.tw``
});

/**
 * The `<legend>` element doesn't participate in `<fieldset>`â€™s flex layout,
 * so we need to use margin instead to create vertical space between the legend
 * and the wrapper.
 * These classes are grouped together in an object to ensure they're always
 * using the same vertical space.
 */
const selectCardVerticalSpaceClasses = {
  gap: tw.tw`gap-x-1 gap-y-2`,
  marginBottom: tw.tw`mb-2`
};

/**
 * Compute the updated value of a control based on the checked state and the new value.
 * For checkboxes, if the control is checked, the new value is added to the existing value list.
 * If the control is unchecked and the value is an array, the new value is removed from the value list.
 * If the value is not an array and the control is unchecked, the value is returned as it is.
 * For radio buttons, the new value is returned as it is.
 *
 * @param controlType - The type of control ('checkbox' or 'radio')
 * @param checked - Whether the control is checked
 * @param value - The current value of the control
 * @param newValue - The new value to be added to the control
 * @returns The updated value of the control
 */
function computeUpdatedValue(controlType, checked, value, newValue) {
  if (controlType === 'checkbox') {
    if (checked) {
      return [...value, newValue]; // if its checked add the value to existing value list
    }
    if (Array.isArray(value)) {
      return value.filter(v => v !== newValue); // if its array "remove" the newValue from the value list (unchecked)
    }
    return value; // when value is not an array and not checked return the value as it is (don't alter the value as it should not happen)
  }
  return newValue; // For radio button, return the newValue as it is
}

function SelectCard({
  className = '',
  classNames = {},
  controlType = 'radio',
  isDisabled = false,
  legend,
  onChange,
  options,
  orientation = 'horizontal',
  style = {},
  styles = {},
  value,
  ...consumerProps
}) {
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getSelectCardStyles({
      isDisabled,
      orientation
    })
  });
  return /*#__PURE__*/jsxRuntime.jsxs(box.Box, {
    as: "fieldset",
    ...styleProps('root'),
    ...consumerProps,
    children: [legend ? /*#__PURE__*/jsxRuntime.jsx(text.Text, {
      as: "legend",
      ...styleProps('legend'),
      children: legend
    }) : null, options.map(option => {
      const {
        value: optionValue,
        directSlot,
        dynamicSlot,
        transitionHeightClass,
        ...restInputProps
      } = option;
      const isChecked = value === null || value === void 0 ? void 0 : value.includes(optionValue);
      const disabled = option.isDisabled || isDisabled;

      // To fetch styles for each card based on its disabled state
      const optionStyleProps =
      // eslint-disable-next-line react-hooks/rules-of-hooks
      focus_container.useCombinedFocusContainerInputStyles({
        className: '',
        // nullify the className(root) passed by consumer - classNames (cardRow) is enough
        classNames,
        style,
        styles,
        isDisabled: disabled,
        isInvalid: false,
        tw: getCardStyles({
          isDisabled: disabled,
          orientation
        })
      });
      const labelStyles = mergeProps.mergeProps(optionStyleProps('root'),
      // focus-container/styles.ts -> control part
      optionStyleProps('cardRow') // SelectCard/styles.ts -> cardRow part
      );
      return /*#__PURE__*/React.createElement(focus_container.FocusContainer, {
        ...optionStyleProps('card'),
        classNames: {
          center: 'h-full',
          focusIndicator: {
            ...optionStyleProps('focusIndicator')
          }.className
        },
        isDisabled: disabled,
        isInvalid: false // we don't have invalid state for select card
        ,
        key: option.value,
        styles: {
          focusIndicator: {
            ...optionStyleProps('focusIndicator').style
          }
        }
      }, ({
        ref
      }) => {
        const controlInputProps = {
          // allow consumer to pass any other props (even ones not defined in the SelectCardOptionProps - but valid ones) to the input element,
          ...restInputProps,
          // define props required for functionality (like onChange, value, checked, etc) shouldn't override the consumer props
          checked: isChecked,
          isDisabled: disabled,
          ref,
          value: optionValue,
          onChange: ({
            target: {
              checked,
              value: newValue
            }
          }) => {
            if (disabled) return;
            const updatedValue = computeUpdatedValue(controlType, checked, value, newValue);
            onChange(updatedValue); // call the onChange function with updated value
          },
          ...styleProps('controlWrapper') // Targets root part(AlignChildToText) of primitives.
        };
        return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsxs(label.Label, {
            ...labelStyles,
            children: [controlType === 'checkbox' ? /*#__PURE__*/jsxRuntime.jsx(checkbox_primitive.CheckboxPrimitive, {
              ...controlInputProps
            }) : /*#__PURE__*/jsxRuntime.jsx(radioPrimitive.RadioPrimitive, {
              ...controlInputProps
            }), directSlot ? /*#__PURE__*/jsxRuntime.jsx(box.Box, {
              ...styleProps('directContentWrapper'),
              className: twMerge.twMerge(styleProps('directContentWrapper').className, orientation === 'horizontal' && !dynamicSlot ? '-ms-6' : ''),
              children: directSlot
            }) : null]
          }), dynamicSlot ? /*#__PURE__*/jsxRuntime.jsx(box.Box, {
            ...styleProps('dynamicContentWrapper'),
            className: twMerge.twMerge(styleProps('dynamicContentWrapper').className, isChecked ? transitionHeightClass : `h-0 my-0`),
            children: isChecked ? dynamicSlot : null
          }) : null]
        });
      });
    })]
  });
}

exports.SelectCard = SelectCard;
