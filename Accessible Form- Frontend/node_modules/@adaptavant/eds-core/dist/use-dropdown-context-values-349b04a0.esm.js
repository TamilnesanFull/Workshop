'use client';
import { useReducer, useCallback, useMemo, useId } from 'react';
import { useFieldContext } from './context-2a1498a6.esm.js';
import { c as composeId } from './compose-id-1f2e6139.esm.js';
import { u as updateDescendantSearchTerm, f as findPreviousNonDisabledIndex, a as findNextNonDisabledIndex, b as findLastNonDisabledIndex, c as findFirstNonDisabledIndex, i as isNodeListOfHTMLElements, d as getActiveDescendantId } from './utils-0956ef0f.esm.js';
import { usePopover } from './popover-55e45b10.esm.js';
import { useDebounceFunction } from './use-debounce-function-f581583e.esm.js';

const initialDropdownState = {
  activeDescendantIndex: -1,
  descendantCount: 0,
  descendantNodes: undefined,
  descendantSearchTerm: '',
  isMenuOpen: false,
  lastKeyPressTime: 0,
  selectedOptionId: undefined
};
function dropdownReducer(state, action) {
  const currentTime = new Date().getTime();
  switch (action.type) {
    case 'OPEN_MENU':
      {
        if (state.isMenuOpen) {
          return state; // No need to update state if the menu is already open
        }
        return {
          ...state,
          isMenuOpen: true,
          activeDescendantIndex: -1,
          descendantSearchTerm: ''
        };
      }
    case 'CLOSE_MENU':
      {
        if (!state.isMenuOpen) {
          return state; // No need to update state if the menu is already closed
        }

        // Avoid using initialDropdownState as it will reset lastKeyPressTime
        return {
          ...state,
          isMenuOpen: false,
          activeDescendantIndex: -1,
          descendantNodes: undefined,
          descendantCount: 0,
          descendantSearchTerm: '',
          // Preserve selection
          selectedOptionId: state.selectedOptionId
        };
      }
    case 'ACTIVATE_FIRST_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = findFirstNonDisabledIndex(state.descendantNodes, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the first active non-disabled descendant
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : state; // we've checked all descendants, reached the end, all nodes are disabled - return state unchanged
      }
    case 'ACTIVATE_LAST_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = findLastNonDisabledIndex(state.descendantNodes, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the last active non-disabled descendant
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : state; // we've checked all descendants, reached the start, all nodes are disabled - return state unchanged
      }
    case 'ACTIVATE_NEXT_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = findNextNonDisabledIndex(state.descendantNodes, state.activeDescendantIndex, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the new active descendant index
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : {
          ...state,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        }; // If no active descendant is found, return the current state with updates
      }
    case 'ACTIVATE_PREVIOUS_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = findPreviousNonDisabledIndex(state.descendantNodes, state.activeDescendantIndex, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the new active descendant index
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : {
          ...state,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        }; // If no active descendant is found, return the current state with updates
      }
    case 'SELECT_ITEM':
      {
        // early return if the selected option is already selected
        if (state.selectedOptionId === action.payload.optionId) return state;
        return {
          ...state,
          selectedOptionId: action.payload.optionId
        };
      }
    case 'CLEAR_SELECTED_ITEM':
      {
        // early return if the selected option is already undefined
        if (!state.selectedOptionId) return state;
        return {
          ...state,
          selectedOptionId: undefined
        };
      }
    case 'SET_ACTIVE_DESCENDANT_INDEX':
      {
        // early return if the active index and selected option id are already set
        if (state.activeDescendantIndex === action.payload.activeIndex && state.selectedOptionId === action.payload.activeId) {
          return state;
        }
        return {
          ...state,
          activeDescendantIndex: action.payload.activeIndex,
          selectedOptionId: action.payload.activeId
        };
      }
    case 'SET_HIGHLIGHTED_INDEX':
      {
        // early return if the active index is already set
        if (state.activeDescendantIndex === action.payload.activeIndex) {
          return state;
        }
        return {
          ...state,
          activeDescendantIndex: action.payload.activeIndex
        };
      }
    case 'SET_DESCENDANT_NODES':
      {
        var _action$payload$nodes;
        // early return if the descendant nodes are same or menu is closed
        if (!state.isMenuOpen || state.descendantNodes === action.payload.nodes) return state;

        // update the state with the new descendant nodes
        return {
          ...state,
          descendantCount: ((_action$payload$nodes = action.payload.nodes) === null || _action$payload$nodes === void 0 ? void 0 : _action$payload$nodes.length) ?? 0,
          descendantNodes: action.payload.nodes,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        };
      }
    case 'UPDATE_DESCENDANT_SEARCH_TERM':
      {
        const {
          newState
        } = updateDescendantSearchTerm({
          descendantNodes: state.descendantNodes,
          descendantCount: state.descendantCount,
          activeDescendantIndex: state.activeDescendantIndex,
          lastKeyPressTime: state.lastKeyPressTime,
          currentTime,
          eventKey: action.payload.eventKey,
          descendantSearchTerm: state.descendantSearchTerm
        });
        return {
          ...state,
          ...newState
        };
      }
    default:
      {
        throw new Error(`Unhandled action type: ${action.type}`);
      }
  }
}

/**
 * Hook that provides the values for the DropdownContext.
 */
function useDropdownContextValues({
  popoverMatchReferenceWidth = true,
  popoverMaxHeight = 300,
  popoverMaxWidth = 300,
  popoverOffset = 0,
  popoverPlacement = 'bottom-start',
  strategy = 'absolute'
}) {
  const [state, dispatch] = useReducer(dropdownReducer, initialDropdownState);
  const {
    activeDescendantIndex,
    descendantCount,
    descendantNodes,
    descendantSearchTerm,
    isMenuOpen,
    lastKeyPressTime,
    selectedOptionId
  } = state;
  const {
    baseId,
    listId,
    popoverId,
    triggerId,
    comboboxId
  } = useDropdownIds();
  const popover = usePopover({
    matchReferenceWidth: popoverMatchReferenceWidth,
    maxHeight: popoverMaxHeight,
    maxWidth: popoverMaxWidth,
    offset: popoverOffset,
    placement: popoverPlacement,
    isOpen: isMenuOpen,
    isPopoverAlwaysMounted: true,
    strategy
  });
  const openMenu = useCallback(() => dispatch({
    type: 'OPEN_MENU'
  }), []);
  const closeMenuAction = useCallback(() => {
    dispatch({
      type: 'CLOSE_MENU'
    });
  }, []);
  const debouncedCloseMenuAction = useDebounceFunction(closeMenuAction, 50);
  const closeMenu = useCallback(() => {
    // Check if referenceRef is an HTMLElement before attempting to focus it
    if (popover.referenceRef.current instanceof HTMLElement) {
      var _popover$referenceRef;
      // Focus the trigger button when closing the menu, but prevent scrolling
      (_popover$referenceRef = popover.referenceRef.current) === null || _popover$referenceRef === void 0 || _popover$referenceRef.focus({
        preventScroll: true
      });
    }
    debouncedCloseMenuAction();
  }, [debouncedCloseMenuAction, popover.referenceRef]);
  const toggleMenu = useCallback(() => {
    isMenuOpen ? closeMenu() : openMenu();
  }, [closeMenu, isMenuOpen, openMenu]);
  const goToFirstMenuItem = useCallback(() => dispatch({
    type: 'ACTIVATE_FIRST_DESCENDANT'
  }), []);
  const goToLastMenuItem = useCallback(() => dispatch({
    type: 'ACTIVATE_LAST_DESCENDANT'
  }), []);
  const goToPreviousMenuItem = useCallback(() => dispatch({
    type: 'ACTIVATE_PREVIOUS_DESCENDANT'
  }), []);
  const goToNextMenuItem = useCallback(() => dispatch({
    type: 'ACTIVATE_NEXT_DESCENDANT'
  }), []);
  const updateDescendantSearchTerm = useCallback(eventKey => {
    dispatch({
      type: 'UPDATE_DESCENDANT_SEARCH_TERM',
      payload: {
        eventKey
      }
    });
  }, []);
  const selectItem = useCallback(optionId => {
    dispatch({
      type: 'SELECT_ITEM',
      payload: {
        optionId
      }
    });
  }, []);
  const clearSelectedItem = useCallback(() => {
    dispatch({
      type: 'CLEAR_SELECTED_ITEM'
    });
  }, []);
  const clickSelectedItem = useCallback(() => {
    // Add check to ensure there are selectable items
    if (activeDescendantIndex === -1 || descendantCount === 0) return;

    // Ensure descendantNodes is not undefined and has items
    if (!isNodeListOfHTMLElements(descendantNodes)) return;
    const activeDescendant = descendantNodes[activeDescendantIndex];

    // Ensure the active descendant is a valid HTMLElement before attempting to click
    if (!(activeDescendant instanceof HTMLElement)) return;

    // Click the active descendant
    activeDescendant.click();
  }, [activeDescendantIndex, descendantCount, descendantNodes]);
  const activeDescendantId = getActiveDescendantId(state);
  const contextValue = useMemo(() => ({
    activeDescendantId,
    activeDescendantIndex,
    baseId,
    clearSelectedItem,
    clickSelectedItem,
    closeMenu,
    comboboxId,
    descendantCount,
    descendantNodes,
    descendantSearchTerm,
    dispatch,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem,
    isMenuOpen,
    lastKeyPressTime,
    listId,
    openMenu,
    popover,
    popoverId,
    selectedOptionId,
    selectItem,
    toggleMenu,
    triggerId,
    updateDescendantSearchTerm
  }), [activeDescendantId, activeDescendantIndex, baseId, clearSelectedItem, clickSelectedItem, closeMenu, comboboxId, descendantCount, descendantNodes, descendantSearchTerm, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem, isMenuOpen, lastKeyPressTime, listId, openMenu, popover, popoverId, selectedOptionId, selectItem, toggleMenu, triggerId, updateDescendantSearchTerm]);
  return contextValue;
}

/**
 * Generates the ID of the dropdown's container element, trigger and popover
 * panel.
 *
 * These are generated together as they are connected by
 * aria-controls/aria-labelledby. The `baseId` prefix ensures that IDs are
 * unique so that multiple dropdowns can be placed on the same page.
 */
function useDropdownIds() {
  const id = useId();
  const baseId = `dropdown-${id}`;
  let triggerId;
  /**
   * It's OK to call useContext conditionally.
   * @see https://twitter.com/acdlite/status/1581401077915975680
   */
  try {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    triggerId = useFieldContext().controlId;
  } catch {
    triggerId = composeId(baseId, 'trigger');
  }
  return {
    baseId,
    listId: composeId(baseId, 'list'),
    popoverId: composeId(baseId, 'popover'),
    comboboxId: composeId(baseId, 'combobox'),
    triggerId
  };
}

export { useDropdownContextValues };
