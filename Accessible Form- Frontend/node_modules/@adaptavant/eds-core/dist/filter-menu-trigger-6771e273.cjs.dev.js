'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var context$1 = require('./context-1e651be3.cjs.dev.js');
var index = require('./index-3bdbdb42.cjs.dev.js');
var forwardRef = require('./forward-ref-6c731e6e.cjs.dev.js');
var mergeProps = require('./merge-props-74bd38ff.cjs.dev.js');
var styles = require('./styles-590374a3.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var dropdownUpIcon = require('./dropdown-up-icon-9612d99c.cjs.dev.js');
var dropdownDownIcon = require('./dropdown-down-icon-e861b656.cjs.dev.js');
var box = require('./box-88b49271.cjs.dev.js');
var context = require('./context-fb7f9049.cjs.dev.js');
var focus_container = require('./focus-container-f89af8ff.cjs.dev.js');
var button = require('./button-4b229f71.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');
require('./cx-26784cbb.cjs.dev.js');
require('clsx');
require('./merge-ids-b19ec20e.cjs.dev.js');
require('./styles-3e350289.cjs.dev.js');
require('./tw-cabb7e4c.cjs.dev.js');
require('./styles-32c512c4.cjs.dev.js');

const FilterMenuTrigger = forwardRef.forwardRefWithGenericComponent(function FilterMenuTrigger({
  children,
  className = '',
  classNames = {},
  iconEnd,
  placeholder,
  style = {},
  styles: styles$1 = {},
  ...consumerProps
}, forwardedRef) {
  const {
    isDisabled,
    isInvalid,
    size,
    variant
  } = context.useFieldContext();
  const context$2 = context$1.useDropdownContext();
  const {
    triggerProps
  } = useFilterMenuTriggerProps(context$2);
  const contentLabel = React.useId();
  const defaultIconEnd = context$2.isMenuOpen ? dropdownUpIcon.DropdownUpIcon : dropdownDownIcon.DropdownDownIcon;
  const ChildrenOrPlaceholder = React.useCallback(() => {
    if (children) return children;
    return (
      /*#__PURE__*/
      // We want to inherit the font size here, so we're using Box
      // instead of Text, as Text comes with a default font size.
      jsxRuntime.jsx(box.Box, {
        as: "span",
        className: "text-secondary group-aria-disabled:text-disabled",
        children: placeholder
      })
    );
  }, [children, placeholder]);
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles: styles$1,
    tw: styles.getFilterMenuTriggerStyles({
      size
    })
  });
  const rootStyles = styleProps('root');
  const labelStyles = styleProps('label');
  const labelTrackStyles = styleProps('labelTrack');
  const chevronStyles = styleProps('chevron');
  const triggerStyleProps = {
    ...rootStyles,
    classNames: {
      iconEnd: chevronStyles.className,
      label: labelStyles.className,
      labelTrack: labelTrackStyles.className
    },
    styles: {
      iconEnd: chevronStyles.style,
      label: labelStyles.style,
      labelTrack: labelTrackStyles.style
    }
  };
  return /*#__PURE__*/jsxRuntime.jsx(focus_container.FocusContainer, {
    isDisabled: isDisabled,
    isGhost: variant === 'subtle',
    isInvalid: isInvalid,
    ...styleProps('focusContainer'),
    classNames: {
      focusIndicator: {
        ...styleProps('focusIndicator')
      }.className
    },
    styles: {
      focusIndicator: {
        ...styleProps('focusIndicator').style
      }
    },
    children: () => /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsxs(box.Box, {
        as: "span",
        className: "sr-only",
        id: contentLabel,
        children: [', ', /*#__PURE__*/jsxRuntime.jsx(ChildrenOrPlaceholder, {})]
      }), /*#__PURE__*/jsxRuntime.jsx(button.Button, {
        ...mergeProps.mergeProps(consumerProps, triggerProps, {
          /*
           * Although `triggerProps` includes `aria-labelledby`, we must
           * append `contentLabel` from this component, not present in
           * `triggerProps`. `mergeProps` automatically combines
           * `aria-labelledby` attributes for us.
           */
          'aria-labelledby': contentLabel
        }),
        iconEnd: iconEnd ? iconEnd : defaultIconEnd,
        isDisabled: isDisabled,
        ref: utils.mergeRefs(triggerProps.ref, forwardedRef),
        size: size,
        variant: "neutralSecondary",
        ...triggerStyleProps,
        children: /*#__PURE__*/jsxRuntime.jsx(ChildrenOrPlaceholder, {})
      })]
    })
  });
});
function useFilterMenuTriggerProps({
  descendantNodes,
  goToFirstMenuItem,
  goToLastMenuItem,
  isMenuOpen,
  openMenu,
  popover,
  popoverId,
  toggleMenu,
  triggerId
}) {
  const {
    isDisabled,
    isInvalid,
    isRequired,
    labelId
  } = context.useFieldContext();
  const a11yProps = context.useInputA11yProps({
    id: triggerId,
    isDisabled,
    isInvalid,
    isRequired
  });
  const [lastKeyPressed, setLastKeyPressed] = React.useState();
  React.useEffect(() => {
    if (!isMenuOpen || !descendantNodes || !lastKeyPressed) return;
    if (lastKeyPressed === 'ArrowUp') {
      goToLastMenuItem();
    } else {
      goToFirstMenuItem();
    }
    setLastKeyPressed(undefined);
  }, [descendantNodes, goToFirstMenuItem, goToLastMenuItem, isMenuOpen, lastKeyPressed]);
  const onKeyDown = React.useCallback(event => {
    if (!supportedKeys.includes(event.code)) return;
    event.preventDefault();
    setLastKeyPressed(event.code);
    openMenu();
  }, [openMenu]);
  return {
    triggerProps: {
      ...popover.getReferenceProps(),
      ...a11yProps,
      'aria-controls': popoverId,
      'aria-expanded': isMenuOpen,
      'aria-haspopup': 'listbox',
      'aria-labelledby': labelId,
      onClick: isDisabled ? undefined : toggleMenu,
      onKeyDown: isDisabled ? undefined : onKeyDown
    }
  };
}
const supportedKeys = ['ArrowDown', 'ArrowUp', 'Enter', 'Space'];

exports.FilterMenuTrigger = FilterMenuTrigger;
exports.useFilterMenuTriggerProps = useFilterMenuTriggerProps;
