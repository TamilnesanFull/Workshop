'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var focus = require('@react-aria/focus');
var React = require('react');
var context = require('./context-1d4965bb.cjs.dev.js');
var styles = require('./styles-5c1faeec.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var mergeProps = require('./merge-props-74bd38ff.cjs.dev.js');
var index = require('./index-3bdbdb42.cjs.dev.js');
require('./tw-cabb7e4c.cjs.dev.js');
require('@react-aria/utils');
require('./cx-26784cbb.cjs.dev.js');
require('clsx');
require('./merge-ids-b19ec20e.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');

/**
 * Represents an individual tab item within the tabs component
 */
function TabItem({
  children,
  className = '',
  classNames = {},
  disabled,
  style = {},
  styles: styles$1 = {},
  value,
  ...consumerProps
}) {
  const {
    size
  } = context.useTabsContext();
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles: styles$1,
    tw: styles.getTabItemStyles({
      size
    })
  });
  const isMounted = React.useRef(false);
  const tabItemRef = React.useRef(null);
  const focusManager = focus.useFocusManager();
  const {
    selectedValue,
    onSelectedValueChange,
    tabItemA11yProps,
    onSelectedElementChange
  } = context.useTabsContext(value, disabled);
  const onKeyDown = e => {
    switch (e.key) {
      case 'ArrowRight':
        focusManager.focusNext({
          wrap: true
        });
        break;
      case 'ArrowLeft':
        focusManager.focusPrevious({
          wrap: true
        });
        break;
    }
  };
  const scrollIntoView = React.useCallback(node => {
    if (node && selectedValue === value) {
      node.scrollIntoView({
        inline: 'center',
        block: 'nearest',
        behavior: 'smooth'
      });
    }
  }, [selectedValue, value]);
  React.useEffect(() => {
    if (selectedValue === value && onSelectedElementChange) {
      onSelectedElementChange(tabItemRef.current);
    }
  }, [onSelectedElementChange, selectedValue, value]);

  // Bypass the scrollIntoView on initial hydration using isMounted ref.
  React.useEffect(() => {
    if (isMounted.current) {
      scrollIntoView(tabItemRef.current);
    }
    isMounted.current = true;
  }, [scrollIntoView]);
  return /*#__PURE__*/jsxRuntime.jsx("button", {
    ...mergeProps.mergeProps(consumerProps, tabItemA11yProps),
    onClick: () => {
      onSelectedValueChange && onSelectedValueChange(value);
    },
    onKeyDown: onKeyDown,
    ref: tabItemRef,
    ...styleProps('root'),
    tabIndex: selectedValue === value ? 0 : -1 // Tabindex for tab item is handled from the component instead of the context (tabItemAllyProps), as we don't  want to restrict the tabbing when used as a custom component
    ,
    children: children
  });
}
TabItem.displayName = 'TabItem';

exports.TabItem = TabItem;
