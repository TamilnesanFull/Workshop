'use client';
import { clsx } from 'clsx';
import Cropper from 'cropperjs';
import { forwardRef, useRef, useEffect } from 'react';
import { jsx } from 'react/jsx-runtime';
import { useCombinedRefs } from './use-combined-refs-1e0ccd00.esm.js';

const applyDefaultOptions = (cropperInstance, {
  enable = true,
  rotateTo,
  scaleX = 1,
  scaleY = 1,
  zoomTo = 0
} = {}) => {
  cropperInstance[enable ? 'enable' : 'disable']();
  cropperInstance.scaleX(scaleX);
  cropperInstance.scaleY(scaleY);
  if (rotateTo !== undefined) {
    cropperInstance.rotateTo(rotateTo);
  }
  if (zoomTo > 0) {
    cropperInstance.zoomTo(zoomTo);
  }
};

const cropperProps = ['aspectRatio', 'autoCrop', 'autoCropArea', 'background', 'center', 'checkCrossOrigin', 'checkOrientation', 'cropBoxMovable', 'cropBoxResizable', 'data', 'dragMode', 'guides', 'highlight', 'initialAspectRatio', 'minCanvasHeight', 'minCanvasWidth', 'minContainerHeight', 'minContainerWidth', 'minCropBoxHeight', 'minCropBoxWidth', 'modal', 'movable', 'preview', 'responsive', 'restore', 'rotatable', 'scalable', 'toggleDragModeOnDblclick', 'viewMode', 'wheelZoomRatio', 'zoomOnTouch', 'zoomOnWheel', 'zoomable', 'cropstart', 'cropmove', 'cropend', 'crop', 'zoom', 'ready'];
const filterOutCropperProps = imageProps => {
  return cropperProps.reduce((acc, key) => {
    const {
      [key]: _,
      ...restProps
    } = acc;
    return restProps;
  }, imageProps);
};

const REQUIRED_IMAGE_STYLES = {
  opacity: 0,
  maxWidth: '100%'
};
const CropperComponentWithoutRef = ({
  alt = 'picture',
  className,
  crossOrigin,
  dragMode = 'crop',
  enable,
  isCircleViewBox,
  onInitialized,
  ready,
  rotateTo,
  scaleX,
  scaleY,
  src,
  style,
  zoomTo,
  ...restProps
}, ref) => {
  const defaultOptions = {
    scaleY,
    scaleX,
    enable,
    zoomTo,
    rotateTo
  };
  const internalRef = useRef(null);
  const combinedRef = useCombinedRefs(ref, internalRef);
  useEffect(() => {
    var _combinedRef$current;
    if ((_combinedRef$current = combinedRef.current) !== null && _combinedRef$current !== void 0 && _combinedRef$current.cropper && typeof zoomTo === 'number') {
      combinedRef.current.cropper.zoomTo(zoomTo);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [zoomTo]);
  useEffect(() => {
    var _combinedRef$current2;
    if ((_combinedRef$current2 = combinedRef.current) !== null && _combinedRef$current2 !== void 0 && _combinedRef$current2.cropper && src !== undefined) {
      combinedRef.current.cropper.reset().clear().replace(src);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [src]);
  useEffect(() => {
    const ref = combinedRef.current;
    if (ref !== null) {
      const cropper = new Cropper(ref, {
        dragMode,
        ...restProps,
        ready: event => {
          if (event.currentTarget !== null) {
            applyDefaultOptions(event.currentTarget.cropper, defaultOptions);
          }
          if (typeof ready === 'function') {
            ready(event);
          }
        }
      });
      if (typeof onInitialized === 'function') {
        onInitialized(cropper);
      }
    }
    return () => {
      var _ref$cropper;
      ref === null || ref === void 0 || (_ref$cropper = ref.cropper) === null || _ref$cropper === void 0 || _ref$cropper.destroy();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [combinedRef]);
  return /*#__PURE__*/jsx("div", {
    className: clsx({
      'cropper-circle-view-box': isCircleViewBox
    }, className),
    style: style,
    children: /*#__PURE__*/jsx("img", {
      ...filterOutCropperProps({
        ...restProps,
        crossOrigin,
        src
      }),
      alt: alt,
      ref: combinedRef,
      style: REQUIRED_IMAGE_STYLES
    })
  });
};
const CropperComponent = /*#__PURE__*/forwardRef(CropperComponentWithoutRef);

export { CropperComponent };
