'use strict';

var utils = require('@react-aria/utils');
var cx = require('./cx-26784cbb.cjs.dev.js');
var mergeIds = require('./merge-ids-b19ec20e.cjs.dev.js');

/**
 * Compose multiple functions into a single function. The functions will be
 * called in the order they are passed in.
 */
function chainFunctions(...fns) {
  return (...args) => {
    for (const fn of fns) {
      try {
        fn(...args);
      } catch (error) {
        const errorContext = `Error in function ${fn.name || `at index ${fns.indexOf(fn)}`}`;
        const errorMessage = typeof error === 'string' ? `${errorContext}: ${error}` : error instanceof Error ? `${errorContext}: ${error.message}` : `${errorContext}`;
        throw new Error(errorMessage);
      }
    }
  };
}

/**
 * Merges multiple props objects, intelligently handling refs, event handlers,
 * and class names.
 *
 * - Refs: Supports both callback and object refs, merging them appropriately.
 * - Event Handlers: Chains multiple handlers for the same event.
 * - aria-describedby/aria-labelledby: Merges IDs to reference multiple elements
 *   for accessibility.
 * - className: Uses cx to concatenate classes.
 * - Inline styles and classNames objects: Performs shallow merge.
 *
 *   Note: Conflicts are resolved by preferring the last value provided for a
 *   given key, except for specific merge rules.
 */
function mergeProps(...args) {
  // Start with a copy of the first result
  const result = {
    ...args[0]
  };

  // Loop through the other props objects, starting with the second item
  for (let index = 1; index < args.length; index++) {
    const props = args[index];

    // Merge props
    for (const [key, b] of Object.entries(props)) {
      const a = result[key];

      // Throw if we encounter conflicting IDs
      if (key === 'id' && a && b && a !== b) {
        throw new Error('Conflicting IDs. Please make sure IDs are unique.');
      }

      // Merge refs
      else if (key === 'ref') {
        // Check if either a or b is a ref (either function or object with a
        // current property)
        const aIsRef = a && (typeof a === 'function' || 'current' in a);
        const bIsRef = b && (typeof b === 'function' || 'current' in b);
        if (aIsRef && bIsRef) {
          // Merge refs if both are refs
          result[key] = utils.mergeRefs(a, b);
        } else {
          // Prefer the ref from the most recent props object
          result[key] = bIsRef ? b : aIsRef ? a : null;
        }
      }

      // Chain event handlers
      else if (typeof a === 'function' && typeof b === 'function' && /^on[A-Z]/.test(key)) {
        result[key] = chainFunctions(a, b);
      }

      // Merge aria-describedby or aria-labelledby attributes
      else if (['aria-describedby', 'aria-labelledby'].includes(key)) {
        result[key] = mergeIds.mergeIds(a, b);
      }

      // Use cx to concatenate classNames
      else if (key === 'className') {
        result[key] = cx.cx(a, b);
      }

      // Merge classNames objects and use cx for each property
      else if (key === 'classNames' && typeof a === 'object' && typeof b === 'object') {
        // Assume classNames is an object where each property is a string | undefined
        const classNames = {
          ...a
        };
        for (const key in b) {
          classNames[key] = cx.cx(classNames[key], b[key]);
        }
        result[key] = classNames;
      }

      // Merge inline styles
      else if (key === 'style') {
        result[key] = {
          ...a,
          ...b
        };
      }

      // Merge styles objects
      else if (key === 'styles' && typeof a === 'object' && typeof b === 'object') {
        // Assume styles is an object where each property is a style object
        const styles = {
          ...a
        };
        for (const key in b) {
          styles[key] = {
            ...styles[key],
            ...b[key]
          };
        }
        result[key] = styles;
      }

      // Override remaining props
      else {
        // if the key exists in props (b), always return that value,
        // otherwise return the value from result (a)
        result[key] = key in props ? b : a;
      }
    }
  }
  return result;
}

exports.chainFunctions = chainFunctions;
exports.mergeProps = mergeProps;
