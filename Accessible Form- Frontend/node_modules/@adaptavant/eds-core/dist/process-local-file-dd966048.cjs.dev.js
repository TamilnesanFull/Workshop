'use strict';

var Compressor = require('compressorjs');
var lodash = require('lodash');
var parseImageProcessingOptions = require('./parse-image-processing-options-c3eac627.cjs.dev.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var Compressor__default = /*#__PURE__*/_interopDefault(Compressor);

const DEFAULT_COMPRESS_IMAGE_OPTIONS = {
  strict: true,
  retainExif: false,
  checkOrientation: true,
  resize: 'none',
  mimeType: 'auto',
  quality: 0.6,
  maxWidth: 4096,
  maxHeight: 4096,
  convertSize: 5_000_000,
  convertTypes: ['image/png']
};
const compressImage = (blob, options) => new Promise((resolve, reject) => {
  Reflect.construct(Compressor__default["default"], [blob, {
    ...DEFAULT_COMPRESS_IMAGE_OPTIONS,
    ...options,
    error: reject,
    success: resolve
  }]);
});

const createImageElement = source => new Promise((resolve, reject) => {
  if (typeof source !== 'string') {
    reject(new Error('Source must be a string'));
    return;
  }
  const imageObject = new Image();
  imageObject.addEventListener('load', () => resolve(imageObject));
  imageObject.addEventListener('error', event => reject((event === null || event === void 0 ? void 0 : event.error) ?? new Error('Image loading failed')));
  imageObject.src = source;
});

const createUrl = value => {
  try {
    const url = new URL(value ?? '');
    return {
      url,
      error: null
    };
  } catch (error) {
    return {
      url: null,
      error: error instanceof Error ? error : new Error('Unknown error occurred')
    };
  }
};

const isFileSizeValid = (fileSizeInBytes, maxFileSizeInMegabytes) => fileSizeInBytes <= maxFileSizeInMegabytes * 1024 * 1024;

const handleTryCatchError = ({
  onError,
  error,
  location
}) => {
  if (!onError) {
    return;
  }
  const errorObject = {
    location,
    originalError: error,
    message: 'An unexpected error occurred.'
  };
  if (error instanceof Error) {
    errorObject.name = error.name;
    errorObject.stack = error.stack;
    errorObject.message = error.message;
  } else if (lodash.isString(error)) {
    errorObject.message = error;
  }
  onError(errorObject);
};

const readFileImage = blob => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => resolve(reader.result);
  reader.onerror = () => reject(reader.error);
  reader.readAsDataURL(blob);
});

const DEFAULT_OPTIONS = {
  targetWidth: 4096,
  targetHeight: 4096,
  onError: () => null,
  rescaleWhenSmaller: false
};
const shouldRescale = (imageElement, {
  rescaleWhenSmaller,
  targetHeight,
  targetWidth
}) => rescaleWhenSmaller || targetWidth < imageElement.width || targetHeight < imageElement.height;
const calculateDimensions = (imageElement, {
  targetHeight,
  targetWidth
}) => {
  const scale = Math.min(targetWidth / imageElement.width, targetHeight / imageElement.height);
  return {
    width: imageElement.width * scale,
    height: imageElement.height * scale
  };
};
const createCanvas = (width, height) => {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  return canvas;
};
const drawImageOnCanvas = (image, canvas) => {
  const context = canvas.getContext('2d');
  if (!context) throw new Error('Could not get canvas context');
  context.drawImage(image, 0, 0, canvas.width, canvas.height);
  return canvas;
};
const canvasToBlob = (canvas, type) => new Promise(resolve => {
  canvas.toBlob(resolve, type);
});
const resizeImage = async (blob, options = {}) => {
  const {
    rescaleWhenSmaller,
    targetHeight,
    targetWidth,
    onError
  } = {
    ...DEFAULT_OPTIONS,
    ...options
  };
  try {
    const fileImage = await readFileImage(blob);
    const imageElement = await createImageElement(fileImage);
    if (!shouldRescale(imageElement, {
      rescaleWhenSmaller,
      targetWidth,
      targetHeight
    })) {
      return blob;
    }
    const {
      height,
      width
    } = calculateDimensions(imageElement, {
      targetWidth,
      targetHeight
    });
    const canvas = createCanvas(width, height);
    const canvasWithImage = drawImageOnCanvas(imageElement, canvas);
    const resizedBlob = await canvasToBlob(canvasWithImage, blob.type);
    return resizedBlob ?? blob;
  } catch (error) {
    handleTryCatchError({
      error,
      onError,
      location: 'RESIZE_IMAGE'
    });
    return blob;
  }
};

const isReadFileErrorOnAndroid = error => error instanceof Error ? error.name === 'NotReadableError' : false;
const validateImageType = async (file, acceptedMimeTypes, onError) => {
  if (!file) {
    return {
      isValid: false,
      errorType: null
    };
  }
  const isAcceptedMimeType = acceptedMimeTypes.includes(file.type);
  if (!isAcceptedMimeType) {
    handleTryCatchError({
      onError,
      location: 'VALIDATE_IMAGE_TYPE',
      error: new Error(`File does not have a valid mime type: ${file.type}`)
    });
    return {
      isValid: false,
      errorType: 'mime'
    };
  }
  try {
    const fileImage = await readFileImage(file);
    await createImageElement(fileImage);
    return {
      isValid: true,
      errorType: null
    };
  } catch (error) {
    const isReadError = isReadFileErrorOnAndroid(error);
    handleTryCatchError({
      error,
      onError,
      location: 'VALIDATE_IMAGE_TYPE'
    });
    return {
      isValid: false,
      errorType: isReadError ? 'read-android' : 'other'
    };
  }
};

const getValidationResponse = (validationResult, translations) => {
  if (validationResult.isValid) {
    return {
      isValid: true
    };
  }
  return {
    isValid: false,
    errorMessage: validationResult.errorType === 'read-android' ? translations.androidFileReadError : translations.fileTypeMismatchError
  };
};
const validateImageTypeWithRetries = async (file, allowedMimeTypes, onError) => {
  const firstAttempt = await validateImageType(file, allowedMimeTypes, onError);
  if (firstAttempt.isValid) {
    return firstAttempt;
  }
  return firstAttempt.errorType === 'read-android' ? validateImageType(file, allowedMimeTypes, onError) : firstAttempt;
};
const validateLocalFile = async (file, imageProcessingOptions, translations, onError) => {
  if (!isFileSizeValid(file.size, imageProcessingOptions.maxFileSizeMB)) {
    return {
      isValid: false,
      errorMessage: translations.fileSizeExceedsLimitError
    };
  }
  const result = await validateImageTypeWithRetries(file, imageProcessingOptions.allowedMimeTypes, onError);
  return getValidationResponse(result, translations);
};

const getResponse = (blob, errorMessage) => ({
  blob,
  errorMessage
});
const createInitialBlob = async file => {
  const fileArrayBuffer = await file.arrayBuffer();
  return new Blob([new Uint8Array(fileArrayBuffer)], {
    type: file.type
  });
};
const processLocalFile = async (file, translations, imageProcessingOptions = parseImageProcessingOptions.DEFAULT_IMAGE_PROCESSING_OPTIONS, onError) => {
  const parsedErrorTranslations = parseImageProcessingOptions.parseErrorTranslations(translations);
  const parsedImageProcessingOptions = parseImageProcessingOptions.parseImageProcessingOptions(imageProcessingOptions);
  try {
    const validation = await validateLocalFile(file, parsedImageProcessingOptions, parsedErrorTranslations, onError);
    if (!validation.isValid) {
      return getResponse(null, validation.errorMessage);
    }
    let blob = await createInitialBlob(file);
    if (parsedImageProcessingOptions.enableResize) {
      blob = await resizeImage(file, {
        onError,
        rescaleWhenSmaller: false,
        targetWidth: parsedImageProcessingOptions.maxWidth,
        targetHeight: parsedImageProcessingOptions.maxHeight
      });
    }
    if (parsedImageProcessingOptions.enableCompression) {
      blob = await compressImage(blob, {
        quality: parsedImageProcessingOptions.compressionQuality
      });
    }
    return getResponse(blob);
  } catch (error) {
    handleTryCatchError({
      error,
      onError,
      location: 'PROCESS_LOCAL_FILE'
    });
    return getResponse(null, parsedErrorTranslations.localFileProcessingError);
  }
};

exports.compressImage = compressImage;
exports.createImageElement = createImageElement;
exports.createUrl = createUrl;
exports.handleTryCatchError = handleTryCatchError;
exports.isFileSizeValid = isFileSizeValid;
exports.processLocalFile = processLocalFile;
exports.readFileImage = readFileImage;
exports.resizeImage = resizeImage;
exports.validateImageType = validateImageType;
