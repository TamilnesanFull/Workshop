'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var index = require('./index-7955fb8e.cjs.prod.js');
var visuallyHidden = require('./visually-hidden-dbb08e35.cjs.prod.js');
var use_provided_or_generated_id = require('./use-provided-or-generated-id-95445991.cjs.prod.js');
var tw = require('./tw-9929267e.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var mergeProps = require('./merge-props-60701ce8.cjs.prod.js');
var tooltip = require('./tooltip-4d94a9fb.cjs.prod.js');
var popover = require('./popover-f1e8b1ac.cjs.prod.js');
require('./tw-merge-885aa7a8.cjs.prod.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.prod.js');
require('@react-aria/utils');
require('./cx-86353291.cjs.prod.js');
require('clsx');
require('./merge-ids-2d47bd24.cjs.prod.js');

const getTooltipStyles = () => ({
  root: tw.tw`
			bg-inverse
			border-none
			overflow-y-auto
			px-2
			py-0.5
			rounded-4px
			text-body-12
			text-inverse-secondary
			w-max
		`
});

const TOOLTIP_TIMEOUT_MS = 500;

/**
 * Tooltip
 *
 * @description
 * A popup that displays information related to an element when the element
 * receives keyboard focus or the mouse hovers over it.
 */
function Tooltip({
  children,
  className = '',
  classNames = {},
  content,
  id: idProp,
  maxWidth = 200,
  placement = 'top',
  shouldUsePortal = true,
  strategy = 'absolute',
  style = {},
  styles = {},
  visibilityHidden = false,
  ...consumerProps
}) {
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getTooltipStyles()
  });
  const context = tooltip.useTooltip();
  const tooltipId = use_provided_or_generated_id.useProvidedOrGeneratedId(idProp);
  const isVisible = context.visibleTooltipId === tooltipId;
  const [hideTimeoutId, setHideTimeoutId] = React.useState();
  const [isTouchEvent, setIsTouchEvent] = React.useState(false);
  let prevActiveElement = undefined;
  const clearHideTimeout = React.useCallback(() => {
    //	The check on `context.visibleTooltipId` ensures that the correct tooltip is hidden,
    //   especially when the user hovers over multiple tooltip trigger elements in quick succession.
    //   This solution works best when there is a gap between the tooltip trigger elements.
    //   If no gap exists between them, the issue may still occur.
    if (hideTimeoutId && context.visibleTooltipId) {
      clearTimeout(hideTimeoutId);
      //	The state update for `hideTimeoutId` verifies if the timeout is still valid
      //   (i.e., it checks the previous value of `hideTimeoutId`). This is important in cases
      //   where the tooltip doesn't hide as expected after the cursor leaves the trigger element.
      //   If the previous timeout is the same as the current one, it clears the timeout from the queue
      //   and sets `hideTimeoutId` to `undefined` to prevent lingering tooltips.
      setHideTimeoutId(prevTimeoutId => {
        return prevTimeoutId === hideTimeoutId ? undefined : prevTimeoutId;
      });
      setIsTouchEvent(false);
    }
  }, [context.visibleTooltipId, hideTimeoutId]);
  function showTooltip() {
    if (isTouchEvent) return;
    clearHideTimeout();
    context.showTooltip(tooltipId);
  }
  function startHideTooltip() {
    const timeoutId = window.setTimeout(() => {
      context.hideTooltip(tooltipId);
    }, TOOLTIP_TIMEOUT_MS);
    setHideTimeoutId(timeoutId);
  }
  function hideTooltipImmediately() {
    context.hideTooltip(tooltipId);
  }
  function touchEventHandler() {
    setIsTouchEvent(true);
    clearHideTimeout();
    context.showTooltip(tooltipId);
    startHideTooltip();
  }

  // Cleanup hideTimeoutId when component unmounts or before re-running the effect
  React.useEffect(() => {
    return clearHideTimeout;
  }, [clearHideTimeout]);

  // Effect for handling the Escape key press
  React.useEffect(() => {
    function handleEscape(event) {
      if (event.key === 'Escape') {
        context.hideTooltip(tooltipId);
      }
    }
    if (isVisible) {
      document.addEventListener('keydown', handleEscape);
      return () => {
        document.removeEventListener('keydown', handleEscape);
      };
    }
  }, [context, isVisible, tooltipId]);
  const initialContentRef = React.useRef(content);
  const isInitialContent = content === initialContentRef.current;

  // prop getters for the popover element (the tooltip)
  // and the reference element (the trigger)
  const {
    getPopoverProps,
    getReferenceProps
  } = popover.usePopover({
    maxWidth,
    placement,
    isOpen: isVisible,
    isPopoverAlwaysMounted: true,
    strategy
  });

  // props for the trigger element that the tooltip is anchored to
  const triggerProps = {
    ...getReferenceProps(),
    'aria-describedby': visibilityHidden ? undefined : tooltipId,
    /**
     * On blur, store the current active element in `prevActiveElement`
     * to track which element was previously focused.
     */
    onBlur: visibilityHidden ? undefined : () => {
      prevActiveElement = document.activeElement;
      hideTooltipImmediately();
    },
    /**
     * On focus, check if the current active element is the same as `prevActiveElement`.
     * If they match, this means the focus event was likely triggered by a tab switch,
     * so we prevent the tooltip from showing. Otherwise, show the tooltip.
     */
    onFocus: visibilityHidden ? undefined : () => {
      if (document.activeElement === prevActiveElement) {
        return;
      }
      showTooltip();
    },
    onMouseEnter: visibilityHidden ? undefined : showTooltip,
    onMouseLeave: visibilityHidden ? undefined : startHideTooltip,
    // event to trigger hidetooltip on mobile touch
    onTouchEnd: visibilityHidden ? undefined : touchEventHandler
  };

  // props for the tooltip element
  const tooltipProps = mergeProps.mergeProps(consumerProps, {
    id: tooltipId,
    onMouseEnter: showTooltip,
    onMouseLeave: startHideTooltip,
    onTouchEnd: startHideTooltip,
    role: 'tooltip'
  }, isVisible ? getPopoverProps() : {}, isVisible ? styleProps('root') : {
    style: visuallyHidden.visuallyHiddenStyles
  });

  // pass children the triggerProps so that the consumer can apply them
  // to the own trigger elements.

  const trigger = children({
    triggerProps
  });

  // Trigger an alert announcement when content changes.
  // This is necessary because screen readers don't announce changes
  // in the content of the element referenced by `aria-describedby`.
  // If the content remains unchanged (initial content),
  // suppress the announcement by setting `aria-hidden` to true,
  // as this is not new information.
  const alert = /*#__PURE__*/jsxRuntime.jsx("div", {
    "aria-hidden": isInitialContent,
    className: "sr-only",
    role: "alert",
    children: content
  });
  return visibilityHidden ? /*#__PURE__*/jsxRuntime.jsx(React.Fragment, {
    children: trigger
  }) : /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [trigger, /*#__PURE__*/jsxRuntime.jsxs(popover.Popover, {
      ...tooltipProps,
      shouldUsePortal: shouldUsePortal,
      children: [content, alert]
    })]
  });
}
Tooltip.displayName = 'Tooltip';

exports.Tooltip = Tooltip;
