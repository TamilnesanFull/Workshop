'use client';
import { isAppleDevice, mergeRefs } from '@react-aria/utils';
import { assertNever } from 'emery';
import { forwardRef, useEffect, useRef, useCallback, Fragment } from 'react';
import { useDropdownContext } from './context-6e374e37.esm.js';
import { m as mergeProps } from './merge-props-5c13cba9.esm.js';
import { LiveRegion } from './combobox-search-input-b1486eed.esm.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { SearchInput } from './search-input-c957feb3.esm.js';
import './cx-c5d68be6.esm.js';
import 'clsx';
import './merge-ids-c2d2d3d7.esm.js';

const FilterMenuSearchInput = /*#__PURE__*/forwardRef(function FilterMenuSearchInput({
  onClear,
  ...consumerProps
}, forwardedRef) {
  /**
   * Uses useEffect to clear input when the popover closes.
   *
   * This component doesn't know when it will be unmounted, so we use
   * useEffect's cleanup function to clear the input upon unmounting.
   *
   * The ESLint rule (`react-hooks/exhaustive-deps`) is disabled to prevent
   * adding `onClear` to the dependency array. If `onClear` is defined inline
   * then its identity will change on every render. Including it in the
   * dependencies would cause the cleanup function to run on every update, not
   * just unmount, leading to the input being cleared whenever the component
   * re-renders. This setup ensures the input is only cleared when the component
   * unmounts, as intended.
   */
  useEffect(() => {
    return () => {
      if (onClear) onClear();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const {
    activeDescendantId,
    isMenuOpen,
    listId
  } = useDropdownContext();

  // Ref to track if the component has already been initialized
  const isFirstRenderRef = useRef(true);
  const handleKeyDown = useKeydownNavigation();
  const isAppleDevice$1 = isAppleDevice();

  // When the Filtermenu is opened, the searchbox should be focused in order for
  // the keyboard navigation to work.
  const autoFocusOnOpen = useCallback(node => {
    if (node && isMenuOpen && isFirstRenderRef.current) {
      node.focus({
        preventScroll: true
      });
      isFirstRenderRef.current = false;
    }
  }, [isMenuOpen]);
  const a11yProps = {
    'aria-activedescendant': isAppleDevice$1 ? undefined : activeDescendantId,
    'aria-autocomplete': 'list',
    'aria-controls': listId,
    'aria-expanded': isMenuOpen,
    autoComplete: 'off',
    autoCorrect: 'off',
    role: 'combobox',
    spellCheck: 'false'
  };
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(SearchInput, {
      ...mergeProps(consumerProps, a11yProps, {
        onKeyDown: handleKeyDown,
        onClear
      }),
      ref: mergeRefs(autoFocusOnOpen, forwardedRef)
    }), /*#__PURE__*/jsx(LiveRegion, {})]
  });
});
FilterMenuSearchInput.displayName = 'FilterMenuSearchInput';
const supportedKeys = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'Escape', 'Enter', 'Tab'];
function isSupportedKey(key) {
  return supportedKeys.includes(key);
}
function useKeydownNavigation() {
  const {
    clickSelectedItem,
    closeMenu,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem
  } = useDropdownContext();
  return useCallback(event => {
    // If we don't have a case for the key, we can return early.
    if (!isSupportedKey(event.code)) return;
    switch (event.code) {
      case 'ArrowUp':
        {
          event.preventDefault();
          goToPreviousMenuItem();
          return;
        }
      case 'ArrowDown':
        {
          event.preventDefault();
          goToNextMenuItem();
          return;
        }
      case 'Home':
        {
          event.preventDefault();
          goToFirstMenuItem();
          return;
        }
      case 'End':
        {
          event.preventDefault();
          goToLastMenuItem();
          return;
        }
      case 'Escape':
        {
          closeMenu();
          return;
        }
      case 'Enter':
        {
          event.preventDefault();
          clickSelectedItem();
          return;
        }
      case 'Tab':
        {
          closeMenu();
          return;
        }
      default:
        assertNever(event.code);
    }
  }, [clickSelectedItem, closeMenu, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem]);
}

export { FilterMenuSearchInput };
