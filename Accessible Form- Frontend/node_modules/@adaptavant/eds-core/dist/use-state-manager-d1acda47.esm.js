'use client';
import { useEffect, useState, useCallback } from 'react';
import { b as createUrl, h as handleTryCatchError, p as processLocalFile } from './process-local-file-2972bd92.esm.js';
import { useDeepCompareCallback } from './use-deep-compare-memoize-70b8df88.esm.js';
import 'compressorjs';
import 'lodash';
import './parse-image-processing-options-6f68c68d.esm.js';

const parseImageBlob = blobUrl => {
  try {
    const {
      url
    } = createUrl(blobUrl);
    if (!url || url.protocol !== 'blob:') {
      throw new Error('Invalid protocol');
    }
    return {
      originalUrl: blobUrl,
      originalFullUrl: blobUrl,
      originalCropDimensions: null
    };
  } catch {
    return {
      originalUrl: null,
      originalCropDimensions: null,
      originalFullUrl: null
    };
  }
};

const parseCropDimensions = cropString => {
  const [width, height, left, top] = cropString.split(';').map(Number);
  if (Number.isNaN(width) ?? Number.isNaN(height) ?? Number.isNaN(left) ?? Number.isNaN(top)) {
    return null;
  }
  return {
    width,
    height,
    left,
    top
  };
};
const parseImageUrl = imageUrl => {
  try {
    const {
      url
    } = createUrl(imageUrl);
    if (!url || url.protocol !== 'https:') {
      throw new Error('Invalid protocol');
    }
    const cropSearchParam = url.searchParams.get('crop');
    const cropDimensions = cropSearchParam ? parseCropDimensions(cropSearchParam) : null;
    return {
      originalFullUrl: imageUrl,
      originalCropDimensions: cropDimensions,
      originalUrl: `${url.origin}${url.pathname}`
    };
  } catch {
    return {
      originalUrl: null,
      originalCropDimensions: null,
      originalFullUrl: null
    };
  }
};

const cropDimensionsToQueryParam = cropDimensions => `?crop=${cropDimensions.width};${cropDimensions.height};${cropDimensions.left};${cropDimensions.top}`;

const useChangesSaver = ({
  apiOptions,
  imageMetadata,
  onSuccessfulUpload,
  setErrorMessage,
  setImageMetadata,
  setIsSaving,
  translations,
  onError
}) => {
  const saveChanges = useDeepCompareCallback(async () => {
    const blob = imageMetadata.processedBlob ?? imageMetadata.originalBlob;
    if (!blob || !imageMetadata.updatedCropDimensions) {
      return;
    }
    const onlyCropDimensionsChanged = imageMetadata.hasCropChanged && !imageMetadata.isNewlyUploaded;
    if (onlyCropDimensionsChanged) {
      const newFullUrl = `${imageMetadata.originalUrl}${cropDimensionsToQueryParam(imageMetadata.updatedCropDimensions)}`;
      setImageMetadata({
        ...imageMetadata,
        originalFullUrl: newFullUrl,
        originalCropDimensions: imageMetadata.updatedCropDimensions,
        originalBlob: imageMetadata.processedBlob ?? imageMetadata.originalBlob,
        originalBlobUrl: imageMetadata.processedBlobUrl ?? imageMetadata.originalBlobUrl,
        hasCropChanged: false
      });
      onSuccessfulUpload(newFullUrl);
      return;
    }
    try {
      setIsSaving(true);
      const accessToken = await apiOptions.getAccessToken();
      const googleStorageApiDetails = await apiOptions.fetchGoogleStorageUploadUrl(apiOptions.uploadUrl, accessToken);
      const fileName = `${window.crypto.randomUUID()}.${blob.type.split('/').pop()}`;
      const serveUrl = await apiOptions.sendFormDataRequest(googleStorageApiDetails.upload_url, new File([blob], fileName, {
        type: blob.type
      }), googleStorageApiDetails.formParams);
      if (!serveUrl) {
        throw new Error();
      }
      const newFullUrl = `${serveUrl}${cropDimensionsToQueryParam(imageMetadata.updatedCropDimensions)}`;
      setImageMetadata({
        processedBlob: null,
        originalUrl: serveUrl,
        hasCropChanged: false,
        isNewlyUploaded: false,
        processedBlobUrl: null,
        updatedCropDimensions: null,
        originalFullUrl: newFullUrl,
        originalCropDimensions: imageMetadata.updatedCropDimensions,
        originalBlob: imageMetadata.processedBlob ?? imageMetadata.originalBlob,
        originalBlobUrl: imageMetadata.processedBlobUrl ?? imageMetadata.originalBlobUrl
      });
      onSuccessfulUpload(newFullUrl);
    } catch (error) {
      handleTryCatchError({
        error,
        onError,
        location: 'SAVE_CHANGES'
      });
      setErrorMessage(translations.fileUploadError);
    } finally {
      setIsSaving(false);
    }
  }, [apiOptions, translations, imageMetadata, setIsSaving, setErrorMessage, setImageMetadata, onSuccessfulUpload]);
  return {
    saveChanges
  };
};

const useLocalImageProcessor = ({
  clearErrorMessage,
  imageMetadata,
  imageProcessingOptions,
  setErrorMessage,
  setImageMetadata,
  setIsProcessingLocalFile,
  translations,
  onError
}) => {
  const processLocalImage = useDeepCompareCallback(async file => {
    setIsProcessingLocalFile(true);
    const {
      blob,
      errorMessage
    } = await processLocalFile(file, translations, imageProcessingOptions, onError);
    if (!blob) {
      setErrorMessage(errorMessage || '');
      setIsProcessingLocalFile(false);
      return;
    }
    clearErrorMessage();
    setIsProcessingLocalFile(false);
    setImageMetadata({
      ...imageMetadata,
      processedBlob: blob,
      hasCropChanged: false,
      isNewlyUploaded: true,
      processedBlobUrl: URL.createObjectURL(blob)
    });
  }, [translations, imageMetadata, imageProcessingOptions, setErrorMessage, setImageMetadata, clearErrorMessage, setIsProcessingLocalFile]);
  return {
    processLocalImage
  };
};

const useRemoteImageLoader = ({
  apiOptions,
  imageMetadata,
  imageUrl,
  setErrorMessage,
  setImageMetadata,
  setIsLoadingRemoteImage,
  translations,
  onError
}) => {
  const loadRemoteImage = useDeepCompareCallback(async url => {
    const isBlobUrl = url.startsWith('blob:');
    const parsedUrl = isBlobUrl ? parseImageBlob(url) : parseImageUrl(url);
    if (!parsedUrl.originalUrl) return;
    setIsLoadingRemoteImage(true);
    try {
      const imageBlob = await apiOptions.fetchInitialImageUrl(parsedUrl.originalUrl);
      setImageMetadata({
        ...imageMetadata,
        ...parsedUrl,
        hasCropChanged: false,
        originalBlob: imageBlob,
        isNewlyUploaded: isBlobUrl,
        processedBlob: isBlobUrl ? imageBlob : null,
        originalBlobUrl: URL.createObjectURL(imageBlob),
        processedBlobUrl: isBlobUrl ? URL.createObjectURL(imageBlob) : null
      });
    } catch (error) {
      setErrorMessage(translations.fetchIncomingImageError);
      handleTryCatchError({
        error,
        onError,
        location: 'REMOTE_IMAGE_FETCHING'
      });
    } finally {
      setIsLoadingRemoteImage(false);
    }
  }, [apiOptions, translations, imageMetadata, setErrorMessage, setImageMetadata, setIsLoadingRemoteImage]);
  useEffect(() => {
    const isDifferentUrl = imageUrl !== imageMetadata.originalFullUrl;
    if (!isDifferentUrl) return;
    if (imageUrl) {
      loadRemoteImage(imageUrl);
    } else {
      setImageMetadata({
        originalUrl: null,
        originalBlob: null,
        processedBlob: null,
        processedBlobUrl: null,
        originalBlobUrl: null,
        isNewlyUploaded: false,
        hasCropChanged: false,
        originalFullUrl: null,
        updatedCropDimensions: null,
        originalCropDimensions: null
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [imageUrl]);
};

const useStateManager = ({
  apiOptions,
  imageProcessingOptions,
  imageUrl,
  onSuccessfulUpload,
  translations,
  onError
}) => {
  const [errorMessage, setErrorMessage] = useState();
  const [isSaving, setIsSaving] = useState(false);
  const [isLoadingRemoteImage, setIsLoadingRemoteImage] = useState(false);
  const [isProcessingLocalFile, setIsProcessingLocalFile] = useState(false);
  const [imageMetadata, setImageMetadata] = useState({
    originalUrl: null,
    originalCropDimensions: null,
    originalBlob: null,
    processedBlob: null,
    processedBlobUrl: null,
    originalBlobUrl: null,
    isNewlyUploaded: false,
    hasCropChanged: false,
    originalFullUrl: null,
    updatedCropDimensions: null
  });
  useRemoteImageLoader({
    apiOptions,
    translations,
    imageMetadata,
    imageUrl,
    onError,
    setErrorMessage,
    setImageMetadata,
    setIsLoadingRemoteImage
  });
  const clearErrorMessage = useCallback(() => setErrorMessage(undefined), []);
  const {
    processLocalImage
  } = useLocalImageProcessor({
    translations,
    imageMetadata,
    imageProcessingOptions,
    setErrorMessage,
    setImageMetadata,
    clearErrorMessage,
    onError,
    setIsProcessingLocalFile
  });
  const {
    saveChanges
  } = useChangesSaver({
    apiOptions,
    translations,
    imageMetadata,
    onError,
    setIsSaving,
    setErrorMessage,
    setImageMetadata,
    onSuccessfulUpload
  });
  const updateCropDimensions = useCallback(newCropDimensions => {
    setImageMetadata(prevMetadata => ({
      ...prevMetadata,
      updatedCropDimensions: newCropDimensions,
      hasCropChanged: JSON.stringify(newCropDimensions) !== JSON.stringify(prevMetadata.originalCropDimensions)
    }));
    clearErrorMessage();
  }, [clearErrorMessage, setImageMetadata]);
  const resetOnClose = useCallback(() => {
    setImageMetadata(prevProps => ({
      ...prevProps,
      hasCropChanged: false,
      isNewlyUploaded: false,
      processedBlob: null,
      processedBlobUrl: null,
      updatedCropDimensions: null
    }));
    clearErrorMessage();
  }, [clearErrorMessage, setImageMetadata]);
  return {
    isSaving,
    errorMessage,
    imageMetadata,
    isLoadingRemoteImage,
    isProcessingLocalFile,
    saveChanges,
    resetOnClose,
    clearErrorMessage,
    processLocalImage,
    updateCropDimensions
  };
};

export { useStateManager };
