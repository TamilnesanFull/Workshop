'use client';
import { useFloating, offset, flip, size, autoUpdate } from '@floating-ui/react-dom';
import { forwardRef, useEffect } from 'react';
import { g as getStyleProps } from './index-dd10a77e.esm.js';
import { t as tw } from './tw-c6a9a210.esm.js';
import { jsx } from 'react/jsx-runtime';
import { B as Box } from './box-a5dda214.esm.js';
import { useCreatePortal } from './create-portal-5c09fed2.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';

const getPopoverStyles = () => ({
  root: tw`
			[outline:none]
			absolute
			bg-neutral
			border
			border-secondary
			flex
			flex-col
			high-contrast:border-solid
			overflow-hidden
			p-1
			rounded-12px
			shadow-20
			w-full
			z-10
		`
});

// ---------------------------------- Popover ----------------------------------

/**
 * Popover
 *
 * @description
 * The popover component provides the visual styles for popovers.
 * It should be used in conjunction with the `usePopover` hook which handles the
 * positioning logic.
 */

const Popover = /*#__PURE__*/forwardRef(function Popover({
  as = 'div',
  className = '',
  classNames = {},
  shouldUsePortal = false,
  style = {},
  styles = {},
  ...consumerProps
}, forwardedRef) {
  const styleProps = getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getPopoverStyles()
  });
  const createPortal = useCreatePortal();
  const popover = /*#__PURE__*/jsx(Box, {
    ...consumerProps,
    as: as,
    ref: forwardedRef,
    ...styleProps('root')
  });
  return shouldUsePortal ? createPortal(popover) : popover;
});
Popover.displayName = 'Popover';

// -------------------------------- usePopover ---------------------------------

/**
 * usePopover
 *
 * @description
 * The `usePopover` hook handles the positioning logic for popovers.
 */
function usePopover({
  isOpen,
  isPopoverAlwaysMounted = false,
  matchReferenceWidth,
  maxHeight: maxHeightOption,
  maxWidth,
  offset: offsetProp = 4,
  placement = 'bottom-start',
  strategy = 'absolute'
} = {}) {
  const floating = useFloating({
    placement,
    strategy,
    middleware: [
    /**
     * Adds distance between the reference and floating element
     * @see https://floating-ui.com/docs/offset
     */
    offset(offsetProp),
    /**
     * Changes the placement of the floating element in order to keep it in view
     * @see https://floating-ui.com/docs/flip
     */
    flip({
      fallbackStrategy: 'initialPlacement'
    }),
    /**
     * Allows you to change the size of the floating element
     * @see https://floating-ui.com/docs/size
     */
    size({
      padding: offsetProp,
      // Prevents the floating element from hitting the edge of the screen
      apply({
        availableWidth,
        availableHeight,
        elements,
        rects
      }) {
        // Popovers can have a predefined max-height if there is enough room on the screen
        const maxHeight = maxHeightOption && availableHeight > maxHeightOption ? maxHeightOption : availableHeight;
        Object.assign(elements.floating.style, {
          maxHeight: getConstrainedSize({
            availableSize: availableHeight,
            maxSize: maxHeight
          }),
          /**
           * @see https://floating-ui.com/docs/size#match-reference-width
           */
          ...(matchReferenceWidth ? {
            width: `${rects.reference.width}px`
          } : {
            maxWidth: getConstrainedSize({
              availableSize: availableWidth,
              maxSize: maxWidth
            })
          })
        });
      }
    })],
    /**
     * Ensures the floating element remains anchored to its reference element
     * @see https://floating-ui.com/docs/react#anchoring
     */
    ...(!isPopoverAlwaysMounted && {
      whileElementsMounted(referenceEl, floatingEl, update) {
        const cleanup = autoUpdate(referenceEl, floatingEl, update, {
          ancestorScroll: false,
          /**
           * JSDOM does not support ResizeObserver
           * @see https://floating-ui.com/docs/autoupdate#elementresize
           */
          elementResize: typeof ResizeObserver === 'function'
        });
        return cleanup;
      }
    })
  });

  /**
   * Ensures the floating element remains anchored to its reference element when
   * using `display: none` or `visibility: hidden`
   *
   * @see https://floating-ui.com/docs/react#anchoring
   */
  useEffect(() => {
    if (!isOpen || !isPopoverAlwaysMounted) return;
    if (!floating.elements.floating || !floating.elements.reference) return;
    const cleanup = autoUpdate(floating.elements.reference, floating.elements.floating, floating.update, {
      ancestorScroll: false,
      /**
       * JSDOM does not support ResizeObserver
       * @see https://floating-ui.com/docs/autoupdate#elementresize
       */
      elementResize: typeof ResizeObserver === 'function'
    });
    return cleanup;
  }, [floating.elements.floating, floating.elements.reference, floating.update, isOpen, isPopoverAlwaysMounted]);
  function getReferenceProps() {
    return {
      ref: floating.refs.setReference
    };
  }
  function getPopoverProps() {
    return {
      ref: floating.refs.setFloating,
      style: floating.floatingStyles
    };
  }
  return {
    getReferenceProps,
    getPopoverProps,
    referenceRef: floating.refs.reference,
    popoverRef: floating.refs.floating
  };
}
function getConstrainedSize({
  availableSize,
  maxSize
}) {
  if (typeof maxSize === 'number') {
    const size = maxSize ? Math.min(availableSize, maxSize) : availableSize;
    return `${size}px`;
  }
  return maxSize;
}

export { Popover, usePopover };
