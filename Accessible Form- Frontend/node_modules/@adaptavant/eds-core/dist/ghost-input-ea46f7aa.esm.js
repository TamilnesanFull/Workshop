'use client';
import { mergeRefs } from '@react-aria/utils';
import { forwardRef, useCallback } from 'react';
import { t as typography } from './styles-267c9284.esm.js';
import { i as inputHeightStylesLookup, b as inputPaddingStylesLookup } from './styles-12c293a4.esm.js';
import { t as tw } from './tw-c6a9a210.esm.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { T as Text } from './text-3fc88ad6.esm.js';
import { Z as ZeroWidthSpace } from './zero-width-space-1914c889.esm.js';
import { B as Box } from './box-a5dda214.esm.js';
import { useFieldContext, useInputA11yProps } from './context-2a1498a6.esm.js';
import { useCombinedFocusContainerInputStyles, FocusContainer } from './focus-container-9b45fd51.esm.js';
import './index-dd10a77e.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';

const getGhostInputStyles = ({
  hasAdornmentEnd,
  hasAdornmentStart,
  size
}) => ({
  root: tw`
		${inputHeightStylesLookup[size]}
		${inputPaddingStylesLookup['end'][hasAdornmentEnd ? 'withAdornment' : 'withoutAdornment'][size]}
		${inputPaddingStylesLookup['start'][hasAdornmentStart ? 'withAdornment' : 'withoutAdornment'][size]}
		${typography[size]}
		aria-disabled:text-disabled
		bg-transparent
		flex
		leading-8
		text-primary
		[outline:none]
		w-full
	`,
  adornmentEnd: tw`
		${typography[size]}
		flex
		items-center
	`,
  adornmentStart: tw`
		${typography[size]}
		flex
		items-center
	`
});

/**
 * GhostInput
 *
 * @deprecated Field and InlineField now expose a variant via context.
 * (e.g. TextInput nested inside of an InlineField with be receive the 'subtle' variant).
 */
const GhostInput = /*#__PURE__*/forwardRef(function GhostInput({
  adornmentEnd,
  adornmentStart,
  className = '',
  classNames = {},
  style = {},
  styles = {},
  type = 'text',
  ...consumerProps
}, forwardedRef) {
  const {
    isDisabled,
    isInvalid,
    isRequired,
    size
  } = useFieldContext();
  const a11yProps = useInputA11yProps({
    isDisabled,
    isInvalid,
    isRequired
  });
  const styleProps = useCombinedFocusContainerInputStyles({
    className,
    classNames,
    isDisabled,
    isInvalid,
    style,
    styles,
    tw: getGhostInputStyles({
      hasAdornmentEnd: Boolean(adornmentEnd),
      hasAdornmentStart: Boolean(adornmentStart),
      isInvalid,
      size
    })
  });
  const handleKeyDown = useCallback(event => {
    if (isDisabled && event.key !== 'Tab') {
      event.preventDefault();
    }
  }, [isDisabled]);
  return /*#__PURE__*/jsx(FocusContainer, {
    adornmentEnd: adornmentEnd ? /*#__PURE__*/jsxs(Text, {
      ...styleProps('adornmentEnd'),
      children: [/*#__PURE__*/jsx(ZeroWidthSpace, {}), adornmentEnd]
    }) : undefined,
    adornmentStart: adornmentStart ? /*#__PURE__*/jsxs(Text, {
      ...styleProps('adornmentEnd'),
      children: [/*#__PURE__*/jsx(ZeroWidthSpace, {}), adornmentStart]
    }) : undefined,
    isDisabled: isDisabled,
    isGhost: true,
    isInvalid: isInvalid,
    children: ({
      ref
    }) => /*#__PURE__*/jsx(Box, {
      ...consumerProps,
      ...a11yProps,
      as: "input",
      onKeyDown: handleKeyDown,
      ref: mergeRefs(ref, forwardedRef),
      type: type,
      ...styleProps('root')
    })
  });
});

export { GhostInput };
