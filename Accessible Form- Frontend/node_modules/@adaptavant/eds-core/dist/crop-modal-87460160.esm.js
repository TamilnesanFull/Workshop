'use client';
import { useRef, useState, useMemo, useEffect, useCallback } from 'react';
import { jsxs, jsx } from 'react/jsx-runtime';
import { a as parseErrorTranslations, p as parseImageProcessingOptions } from './parse-image-processing-options-6f68c68d.esm.js';
import { r as roundNumberToDecimal, s as sendFormDataRequest, c as clamp } from './send-form-data-request-3f085dcd.esm.js';
import { Tooltip, IconButton, Track, Box, Label, AddOnIcon, Button, ImageIcon, FieldErrorMessage, Text, TextLink, Loading, Modal, ModalHeader, Heading, ModalContent, ModalFooter } from '@adaptavant/eds-core';
import clsx$1, { clsx } from 'clsx';
import { Slider } from '@adaptavant/eds-core/experimental';
import { c as cx } from './cx-c5d68be6.esm.js';
import { UploadFileButton } from './upload-file-button-dd2ea51c.esm.js';
import { useStateRef } from './use-state-ref-caeea518.esm.js';
import { CropperComponent } from './cropper-component-566b00b9.esm.js';
import { useDeepCompareMemo } from './use-deep-compare-memoize-70b8df88.esm.js';
import { useIsViewportBelowOrEqual } from './use-viewport-below-or-equal-b1c12ed0.esm.js';
import { useStateManager } from './use-state-manager-d1acda47.esm.js';

const getEntries = obj => Object.entries(obj);

const normalizeObjectNumbers = (object, decimals) => getEntries(object).reduce((accumulator, [key, value]) => {
  if (typeof value === 'number') {
    accumulator[key] = roundNumberToDecimal(value, decimals);
  }
  return accumulator;
}, object);

const calculateCropDimensions = (cropBoxData, canvasData) => {
  const scaleX = canvasData.naturalWidth / canvasData.width;
  const scaleY = canvasData.naturalHeight / canvasData.height;
  const width = cropBoxData.width * scaleX;
  const height = cropBoxData.height * scaleY;
  const left = (cropBoxData.left - canvasData.left) * scaleX;
  const top = (cropBoxData.top - canvasData.top) * scaleY;
  return normalizeObjectNumbers({
    width,
    height,
    left,
    top
  }, 0);
};

const fetchGoogleStorageUploadUrl = async (url, accessToken) => {
  const response = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  return response.json();
};

const fetchInitialImageUrl = async url => {
  const response = await fetch(url);
  return response.blob();
};

const DEFAULT_API_OPTIONS = {
  uploadUrl: 'UNKNOWN',
  sendFormDataRequest,
  fetchInitialImageUrl,
  fetchGoogleStorageUploadUrl,
  getAccessToken: () => Promise.resolve('UNKNOWN')
};
const parseApiOptions = options => ({
  ...DEFAULT_API_OPTIONS,
  ...options
});

const parseAspectRatio = (aspectRatio, isCircle) => {
  if (isCircle) {
    return 1;
  }
  return clamp(aspectRatio ?? 1, 1 / 20, 20 / 1);
};
const formatNumber = (number, max) => {
  const roundedNumber = roundNumberToDecimal(number, 0);
  const clampedNumber = clamp(roundedNumber, 0, max);
  return clampedNumber % 2 === 0 ? clampedNumber : clampedNumber + 1;
};
const parseCropViewBoxOptions = (cropViewBox, generalOptions) => {
  const aspectRatio = parseAspectRatio(cropViewBox.aspectRatio, cropViewBox.isCircle);
  const width = formatNumber(cropViewBox.width, generalOptions.canvasWidth);
  const height = formatNumber(width / aspectRatio, generalOptions.canvasHeight);
  return {
    ...cropViewBox,
    width,
    height,
    aspectRatio
  };
};

const DEFAULT_GENERAL_OPTIONS = {
  canvasWidth: 500,
  canvasHeight: 300,
  maxScaleFactor: 5,
  totalSidePadding: 48,
  hideZoomSliderOnMobile: true,
  saveButtonVariant: 'accentPrimary'
};
const parseGeneralOptions = (generalOptions = {}, screenWidth) => {
  const unprocessedOutput = {
    ...DEFAULT_GENERAL_OPTIONS,
    ...generalOptions
  };
  return {
    ...unprocessedOutput,
    canvasWidth: Math.min(unprocessedOutput.canvasWidth, screenWidth - unprocessedOutput.totalSidePadding),
    unprocessedCanvasWidth: unprocessedOutput.canvasWidth
  };
};

const calculateInitialZoom = ({
  cropHeight,
  cropWidth,
  maxScaleFactor,
  naturalHeight,
  naturalWidth
}) => {
  const widthRatio = cropWidth / naturalWidth;
  const heightRatio = cropHeight / naturalHeight;
  const minZoom = Math.max(widthRatio, heightRatio);
  const maxZoom = minZoom * maxScaleFactor;
  return normalizeObjectNumbers({
    minZoom,
    maxZoom
  }, 3);
};

const cropDimensionsToCanvasData = (cropDimensions, cropBoxData) => {
  const scale = cropBoxData.width / cropDimensions.width;
  const top = cropBoxData.top - cropDimensions.top * scale;
  const left = cropBoxData.left - cropDimensions.left * scale;
  return normalizeObjectNumbers({
    top,
    left,
    scale
  }, 2);
};

const setCropBoxDimensions = (cropperInstance, minZoom, canvasWidth, canvasHeight, cropWidth, cropHeight) => {
  cropperInstance.zoomTo(minZoom).setCropBoxData({
    width: cropWidth,
    height: cropHeight,
    left: (canvasWidth - cropWidth) / 2,
    top: (canvasHeight - cropHeight) / 2
  }).zoomTo(minZoom);
};
const centerCanvasPosition = (cropperInstance, canvasWidth, canvasHeight, cropWidth, cropHeight) => {
  const prevCanvasData = cropperInstance.getCanvasData();
  cropperInstance.setCanvasData({
    ...prevCanvasData,
    left: canvasWidth / 2 - cropWidth / 2 - (prevCanvasData.width - cropWidth) / 2,
    top: canvasHeight / 2 - cropHeight / 2 - (prevCanvasData.height - cropHeight) / 2
  });
};
const applyCropDimensionsAndZoom = (cropperInstance, cropDimensions, minZoom, maxZoom, setZoom) => {
  if (cropDimensions) {
    const canvasData = cropDimensionsToCanvasData(cropDimensions, cropperInstance.getCropBoxData());
    const correctedScale = clamp(canvasData.scale, minZoom, maxZoom);
    setZoom(correctedScale);
    cropperInstance.zoomTo(correctedScale);
    cropperInstance.moveTo(canvasData.left, canvasData.top);
  }
};
const setupCropperArea = ({
  canvasHeight,
  canvasWidth,
  cropDimensions,
  cropHeight,
  cropperInstance,
  cropWidth,
  maxScaleFactor,
  setZoom,
  setMinZoom
}) => {
  const {
    maxZoom,
    minZoom
  } = calculateInitialZoom({
    ...cropperInstance.getCanvasData(),
    cropWidth,
    cropHeight,
    maxScaleFactor
  });
  setMinZoom(minZoom);
  setZoom(minZoom);
  setCropBoxDimensions(cropperInstance, minZoom, canvasWidth, canvasHeight, cropWidth, cropHeight);
  centerCanvasPosition(cropperInstance, canvasWidth, canvasHeight, cropWidth, cropHeight);
  applyCropDimensionsAndZoom(cropperInstance, cropDimensions, minZoom, maxZoom, setZoom);
};

// TODO: Add to EDS core icons package
const ZoomOutIcon = ({
  className
}) => /*#__PURE__*/jsxs("svg", {
  className: clsx('h-4 w-4', className),
  fill: "none",
  height: 16,
  viewBox: "0 0 17 16",
  width: 16,
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsx("path", {
    d: "m11.167 8h-5.3333",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.2"
  }), /*#__PURE__*/jsx("path", {
    clipRule: "evenodd",
    d: "m8.5 14v0c-3.314 0-6-2.686-6-6v0c0-3.314 2.686-6 6-6v0c3.314 0 6 2.686 6 6v0c0 3.314-2.686 6-6 6z",
    fillRule: "evenodd",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: "1.2"
  })]
});
ZoomOutIcon.displayName = 'ZoomOutIcon';

const IconButtonWithTooltip = ({
  'aria-label': ariaLabel,
  content,
  icon,
  isDisabled,
  onClick,
  dataTestId
}) => !!content && !isDisabled ? /*#__PURE__*/jsx(Tooltip, {
  content: content,
  placement: "bottom",
  shouldUsePortal: false,
  children: ({
    triggerProps
  }) => /*#__PURE__*/jsx(IconButton, {
    "aria-label": ariaLabel,
    className: "h-6 min-w-6",
    "data-testid": dataTestId,
    icon: icon,
    onClick: onClick,
    size: "small",
    type: "button",
    variant: "neutralTertiary",
    ...triggerProps
  })
}) : /*#__PURE__*/jsx(IconButton, {
  "aria-label": ariaLabel,
  className: "h-6 min-w-6",
  "data-testid": dataTestId,
  icon: icon,
  isDisabled: isDisabled,
  onClick: onClick,
  size: "small",
  type: "button",
  variant: "neutralTertiary"
});

const CropArea = ({
  allowedMimeType,
  aspectRatio,
  canvasHeight,
  canvasWidth,
  cropDimensions,
  cropHeight,
  cropWidth,
  imageUrl,
  isCircleViewBox,
  isNewlyUploadedImageProcessing,
  maxScaleFactor,
  onCropEnd,
  onFilesChange,
  onZoomChange,
  translations,
  isResponsiveViewport,
  hideZoomSliderOnMobile
}) => {
  const cropperRef = useRef(null);
  const cropDimensionsRef = useRef(cropDimensions);
  const [zoom, setZoom] = useState();
  const [minZoom, setMinZoom, minZoomRef] = useStateRef();
  const maxZoom = useMemo(() => minZoom && roundNumberToDecimal(minZoom * maxScaleFactor, 3), [maxScaleFactor, minZoom]);
  const zoomSteps = useMemo(() => {
    const step = roundNumberToDecimal(canvasWidth / 10_000, 3);
    return {
      in: step,
      out: -step
    };
  }, [canvasWidth]);
  useEffect(() => {
    cropDimensionsRef.current = cropDimensions;
  }, [cropDimensions]);
  const handleUpdateZoom = useCallback((newZoom, updateCropperInstance = true) => {
    var _cropperRef$current;
    const cropperInstance = (_cropperRef$current = cropperRef.current) === null || _cropperRef$current === void 0 ? void 0 : _cropperRef$current.cropper;
    if (cropperInstance) {
      if (updateCropperInstance) {
        cropperInstance.zoomTo(newZoom);
      }
      setZoom(newZoom);
      onZoomChange(cropperInstance);
    }
  }, [onZoomChange]);
  const handleReady = useCallback(() => {
    var _cropperRef$current2;
    const cropperInstance = (_cropperRef$current2 = cropperRef.current) === null || _cropperRef$current2 === void 0 ? void 0 : _cropperRef$current2.cropper;
    if (cropperInstance) {
      setupCropperArea({
        setZoom,
        cropWidth,
        cropHeight,
        setMinZoom,
        canvasWidth,
        canvasHeight,
        maxScaleFactor,
        cropperInstance,
        cropDimensions: cropDimensionsRef.current
      });
      onZoomChange(cropperInstance);
    }
  }, [cropWidth, cropHeight, canvasWidth, canvasHeight, maxScaleFactor, onZoomChange, setMinZoom]);
  const handleCropEnd = useCallback(() => {
    var _cropperRef$current3;
    const cropperInstance = (_cropperRef$current3 = cropperRef.current) === null || _cropperRef$current3 === void 0 ? void 0 : _cropperRef$current3.cropper;
    if (cropperInstance) {
      onCropEnd(cropperInstance);
    }
  }, [onCropEnd]);
  const handleSliderChange = useCallback(newValue => {
    if (zoom === undefined || minZoom === undefined || maxZoom === undefined) return;
    const newZoom = roundNumberToDecimal(newValue, 3);
    handleUpdateZoom(clamp(newZoom, minZoom, maxZoom));
  }, [handleUpdateZoom, zoom, minZoom, maxZoom]);
  const handleZoomButtonClick = useCallback(direction => {
    if (zoom === undefined || minZoom === undefined || maxZoom === undefined) return;
    const newZoom = roundNumberToDecimal(zoom + zoomSteps[direction], 3);
    handleUpdateZoom(clamp(newZoom, minZoom, maxZoom));
  }, [zoom, minZoom, maxZoom, handleUpdateZoom, zoomSteps]);
  const handleZoomInButtonClick = useCallback(() => handleZoomButtonClick('in'), [handleZoomButtonClick]);
  const handleZoomOutButtonClick = useCallback(() => handleZoomButtonClick('out'), [handleZoomButtonClick]);
  const handleTouchZoomChange = event => {
    if (minZoomRef.current === undefined) {
      return;
    }
    const {
      ratio
    } = event.detail;
    const clampedZoom = clamp(ratio, minZoomRef.current, minZoomRef.current * maxScaleFactor);
    const isOutOfBound = clampedZoom !== ratio;
    if (isOutOfBound) {
      event.preventDefault();
    }
    handleUpdateZoom(roundNumberToDecimal(clampedZoom, 3), isOutOfBound);
  };
  return /*#__PURE__*/jsx(Track, {
    className: "flex-col",
    classNames: {
      railEnd: 'w-full'
    },
    "data-testid": "crop-modal--crop-area",
    railEnd: isResponsiveViewport && hideZoomSliderOnMobile ? null : /*#__PURE__*/jsxs(Box, {
      className: cx('flex items-center justify-center gap-8 w-full', isResponsiveViewport ? 'border-none pb-0 pt-9' : 'border-tertiary border-b-[1px] border-solid py-6'),
      children: [/*#__PURE__*/jsxs(Box, {
        className: "flex w-48 flex-col items-center",
        children: [/*#__PURE__*/jsx(Label, {
          className: "sr-only",
          id: "zoom-slider-label",
          children: "Zoom slider"
        }), zoom !== undefined && minZoom !== undefined && maxZoom !== undefined ? /*#__PURE__*/jsx(Slider, {
          adornmentEnd: /*#__PURE__*/jsx(IconButtonWithTooltip, {
            "aria-label": (translations === null || translations === void 0 ? void 0 : translations.zoomInButtonLabel) ?? AddOnIcon.displayName ?? '',
            content: translations === null || translations === void 0 ? void 0 : translations.zoomInButtonLabel,
            dataTestId: "crop-modal--crop-area--zoom-in-button",
            icon: AddOnIcon,
            isDisabled: zoom >= maxZoom,
            onClick: handleZoomInButtonClick
          }),
          adornmentStart: /*#__PURE__*/jsx(IconButtonWithTooltip, {
            "aria-label": (translations === null || translations === void 0 ? void 0 : translations.zoomOutButtonLabel) ?? ZoomOutIcon.displayName ?? '',
            content: translations === null || translations === void 0 ? void 0 : translations.zoomOutButtonLabel,
            dataTestId: "crop-modal--crop-area--zoom-out-button",
            icon: ZoomOutIcon,
            isDisabled: zoom <= minZoom,
            onClick: handleZoomOutButtonClick
          }),
          ariaLabelledBy: "zoom-slider-label",
          className: "gap-4",
          "data-testid": "crop-modal--crop-area--zoom-slider",
          maxValue: maxZoom,
          minValue: minZoom,
          onValueChange: handleSliderChange,
          step: 0.001,
          value: clamp(zoom, minZoom, maxZoom)
        }) : null]
      }), !isResponsiveViewport && translations !== null && translations !== void 0 && translations.uploadNewButtonLabel ? /*#__PURE__*/jsx(UploadFileButton, {
        accept: allowedMimeType,
        onFilesChange: onFilesChange,
        children: /*#__PURE__*/jsx(Button, {
          "data-testid": "crop-modal--crop-area--upload-button",
          iconStart: ImageIcon,
          isLoading: isNewlyUploadedImageProcessing,
          size: "standard",
          variant: "neutralSecondary",
          children: translations.uploadNewButtonLabel
        })
      }) : null]
    }),
    style: {
      width: canvasWidth
    },
    children: /*#__PURE__*/jsx(CropperComponent, {
      autoCropArea: 1,
      cropBoxMovable: false,
      cropBoxResizable: false,
      cropend: handleCropEnd,
      dragMode: "move",
      guides: false,
      initialAspectRatio: aspectRatio,
      isCircleViewBox: isCircleViewBox,
      ready: handleReady,
      ref: cropperRef,
      restore: false,
      src: imageUrl ?? undefined,
      style: {
        height: canvasHeight,
        width: canvasWidth
      },
      toggleDragModeOnDblclick: false,
      viewMode: 1,
      zoom: handleTouchZoomChange,
      zoomOnTouch: true,
      zoomOnWheel: true
    })
  });
};

const DropArea = ({
  allowedMimeType,
  errorMessage,
  height,
  isLoading,
  onFilesChange,
  translations,
  width
}) => /*#__PURE__*/jsxs(Box, {
  className: clsx$1('rounded-8px bg-canvas relative flex flex-col items-center justify-center border', {
    'pointer-events-none': isLoading,
    'border-secondary': !errorMessage,
    'border-input-critical': !!errorMessage
  }),
  "data-testid": "crop-modal--drop-area",
  style: {
    width,
    height,
    borderStyle: 'dashed'
  },
  children: [/*#__PURE__*/jsx(UploadFileButton, {
    accept: allowedMimeType,
    onFilesChange: onFilesChange,
    children: /*#__PURE__*/jsx(Button, {
      "data-testid": "crop-modal--drop-area--upload-button",
      iconStart: ImageIcon,
      isDisabled: isLoading,
      isLoading: isLoading,
      size: "standard",
      variant: "accentSecondary",
      children: translations.uploadImageButtonLabel
    })
  }), errorMessage ? /*#__PURE__*/jsx(FieldErrorMessage, {
    className: "mt-4",
    "data-testid": "crop-modal--drop-area--error-message",
    children: errorMessage
  }) : null, /*#__PURE__*/jsxs(Text, {
    className: "text-body-12 absolute bottom-4 text-secondary",
    "data-testid": "crop-modal--drop-area--description",
    children: [translations.bottomTextPrefix, translations.bottomLinkText && translations.bottomLinkUrl ? /*#__PURE__*/jsx(TextLink, {
      "data-testid": "crop-modal--drop-area--description--link",
      href: translations.bottomLinkUrl,
      rel: "noopener",
      target: "_blank",
      variant: "accentPrimary",
      children: translations.bottomLinkText
    }) : null, translations.bottomTextSuffix]
  })]
});

const LoaderArea = ({
  height,
  width
}) => /*#__PURE__*/jsx("div", {
  className: "flex items-center justify-center bg-canvas-secondary rounded-8px",
  "data-testid": "crop-modal--loader-area",
  style: {
    width,
    height
  },
  children: /*#__PURE__*/jsx(Loading, {})
});

const TITLE_ID = 'crop-modal-title';
const DESCRIPTION_ID = 'crop-modal-description';
const ModalWrapper = ({
  canvasWidth,
  children,
  errorMessage,
  isCancelDisabled,
  isLoading,
  isOpen = false,
  isSaveDisabled,
  onCancel,
  onClose,
  onSave,
  saveButtonVariant,
  translations,
  classNames,
  totalSidePadding,
  isResponsiveViewport,
  unprocessedCanvasWidth
}) => {
  return isOpen ? /*#__PURE__*/jsxs(Modal, {
    className: clsx('bg-canvas', {
      'gap-5': isResponsiveViewport,
      'gap-2': !isResponsiveViewport
    }),
    classNames: {
      modalWrapper: clsx('px-0 z-[1200]', {
        'py-4': !isResponsiveViewport,
        'py-0 items-end': isResponsiveViewport
      }, classNames === null || classNames === void 0 ? void 0 : classNames.modalWrapper)
    },
    closeOnEsc: !isLoading,
    closeOnOverlayClick: !isLoading,
    descriptionId: DESCRIPTION_ID,
    mobileFriendly: true,
    onClose: onClose,
    open: isOpen,
    role: "dialog",
    size: canvasWidth + totalSidePadding,
    titleId: TITLE_ID,
    togglePoint: unprocessedCanvasWidth + totalSidePadding,
    children: [/*#__PURE__*/jsx(ModalHeader, {
      className: clsx('pr-6', {
        'pointer-events-none select-none': isLoading
      }),
      closeButtonProps: {
        onClick: onClose,
        label: translations.closeModalButtonLabel
      },
      children: /*#__PURE__*/jsx(Heading, {
        as: "h3",
        className: "text-heading-16 font-stronger",
        "data-testid": "crop-modal--title",
        id: TITLE_ID,
        children: isResponsiveViewport ? null : translations.title
      })
    }), /*#__PURE__*/jsxs(ModalContent, {
      className: clsx('overflow-hidden', {
        'pointer-events-none select-none': isLoading
      }),
      children: [/*#__PURE__*/jsx(Text, {
        className: "text-body-12 mb-4 text-secondary",
        "data-testid": "crop-modal--subtitle",
        id: DESCRIPTION_ID,
        children: isResponsiveViewport ? null : translations.subtitle
      }), children]
    }), /*#__PURE__*/jsxs(ModalFooter, {
      className: clsx('pt-4', {
        'pointer-events-none select-none': isLoading,
        'flex flex-col pb-3': isResponsiveViewport
      }),
      children: [errorMessage ? /*#__PURE__*/jsx(FieldErrorMessage, {
        className: "mr-auto",
        classNames: {
          errorMessage: clsx({
            'text-body-14': isResponsiveViewport
          })
        },
        "data-testid": "crop-modal--error-message",
        children: errorMessage
      }) : null, isResponsiveViewport ? null : /*#__PURE__*/jsx(Button, {
        "data-testid": "crop-modal--cancel-button",
        isDisabled: isCancelDisabled,
        onClick: onCancel,
        variant: "neutralTertiary",
        children: translations.cancelButtonLabel
      }), /*#__PURE__*/jsx(Button, {
        className: clsx({
          'w-full': isResponsiveViewport
        }),
        "data-testid": "crop-modal--save-button",
        isDisabled: isSaveDisabled,
        isLoading: isLoading,
        onClick: onSave,
        size: isResponsiveViewport ? 'large' : 'standard',
        variant: saveButtonVariant,
        children: translations.saveButtonLabel
      })]
    })]
  }) : null;
};

const CropModal = ({
  apiOptions,
  cropAreaTranslations,
  cropViewBoxOptions,
  dropAreaTranslations,
  errorTranslations,
  generalOptions,
  imageProcessingOptions,
  imageUrl,
  isOpen,
  classNames,
  modalWrapperTranslations,
  onCancel,
  onClose,
  onError,
  onSuccessfulUpload
}) => {
  const screenWidth = typeof window !== 'undefined' ? window.innerWidth : 0;
  const parsedErrorTranslations = useDeepCompareMemo(() => parseErrorTranslations(errorTranslations), [errorTranslations]);
  const parsedApiOptions = useDeepCompareMemo(() => parseApiOptions(apiOptions), [apiOptions]);
  const parsedGeneralOptions = useDeepCompareMemo(() => parseGeneralOptions(generalOptions, screenWidth), [generalOptions, screenWidth]);
  const parsedCropViewBoxOptions = useDeepCompareMemo(() => parseCropViewBoxOptions(cropViewBoxOptions, parsedGeneralOptions), [cropViewBoxOptions, parsedGeneralOptions]);
  const parsedImageProcessingOptions = useDeepCompareMemo(() => parseImageProcessingOptions(imageProcessingOptions), [imageProcessingOptions]);
  const isResponsiveViewport = useIsViewportBelowOrEqual(parsedGeneralOptions.unprocessedCanvasWidth + parsedGeneralOptions.totalSidePadding);
  const {
    isSaving,
    errorMessage,
    imageMetadata,
    isLoadingRemoteImage,
    isProcessingLocalFile,
    saveChanges,
    resetOnClose,
    processLocalImage,
    updateCropDimensions
  } = useStateManager({
    imageUrl,
    onError,
    onSuccessfulUpload,
    apiOptions: parsedApiOptions,
    translations: parsedErrorTranslations,
    imageProcessingOptions: parsedImageProcessingOptions
  });
  const handleClose = useCallback(() => {
    resetOnClose();
    onClose();
  }, [onClose, resetOnClose]);
  const handleCancel = useCallback(() => {
    resetOnClose();
    onCancel();
  }, [onCancel, resetOnClose]);
  const handleCropAreaChange = useCallback(cropperInstance => {
    const cropData = cropperInstance.getCropBoxData();
    const canvasData = cropperInstance.getCanvasData();
    const cropDimensions = calculateCropDimensions(cropData, canvasData);
    updateCropDimensions(cropDimensions);
  }, [updateCropDimensions]);
  const handleFilesChange = useCallback(files => {
    if (files[0]) {
      processLocalImage(files[0]);
    }
  }, [processLocalImage]);
  const hasOriginalOrUploadedFile = !!imageMetadata.originalBlob || !!imageMetadata.processedBlob;
  const showLoadingArea = isLoadingRemoteImage && !hasOriginalOrUploadedFile;
  const showCropArea = !showLoadingArea && hasOriginalOrUploadedFile;
  return /*#__PURE__*/jsxs(ModalWrapper, {
    canvasWidth: parsedGeneralOptions.canvasWidth,
    classNames: classNames,
    errorMessage: showCropArea ? errorMessage : undefined,
    isCancelDisabled: isSaving || isProcessingLocalFile,
    isLoading: isSaving || isProcessingLocalFile,
    isOpen: isOpen,
    isResponsiveViewport: isResponsiveViewport,
    isSaveDisabled: !imageMetadata.isNewlyUploaded && !imageMetadata.hasCropChanged || !hasOriginalOrUploadedFile && !!errorMessage,
    onCancel: handleCancel,
    onClose: handleClose,
    onSave: saveChanges,
    saveButtonVariant: parsedGeneralOptions.saveButtonVariant,
    totalSidePadding: parsedGeneralOptions.totalSidePadding,
    translations: modalWrapperTranslations,
    unprocessedCanvasWidth: parsedGeneralOptions.unprocessedCanvasWidth,
    children: [showLoadingArea ? /*#__PURE__*/jsx(LoaderArea, {
      height: parsedGeneralOptions.canvasHeight,
      width: parsedGeneralOptions.canvasWidth
    }) : null, showCropArea ? /*#__PURE__*/jsx(CropArea, {
      allowedMimeType: parsedImageProcessingOptions.allowedMimeType,
      aspectRatio: parsedCropViewBoxOptions.aspectRatio,
      canvasHeight: parsedGeneralOptions.canvasHeight,
      canvasWidth: parsedGeneralOptions.canvasWidth,
      cropDimensions: imageMetadata.isNewlyUploaded ? null : imageMetadata.originalCropDimensions,
      cropHeight: parsedCropViewBoxOptions.height,
      cropWidth: parsedCropViewBoxOptions.width,
      hideZoomSliderOnMobile: parsedGeneralOptions.hideZoomSliderOnMobile,
      imageUrl: imageMetadata.isNewlyUploaded ? imageMetadata.processedBlobUrl : imageMetadata.originalBlobUrl,
      isCircleViewBox: parsedCropViewBoxOptions.isCircle,
      isNewlyUploadedImageProcessing: isProcessingLocalFile,
      isResponsiveViewport: isResponsiveViewport,
      maxScaleFactor: parsedGeneralOptions.maxScaleFactor,
      onCropEnd: handleCropAreaChange,
      onFilesChange: handleFilesChange,
      onZoomChange: handleCropAreaChange,
      translations: cropAreaTranslations
    }) : null, showCropArea || !dropAreaTranslations ? null : /*#__PURE__*/jsx(DropArea, {
      allowedMimeType: parsedImageProcessingOptions.allowedMimeType,
      errorMessage: errorMessage,
      height: parsedGeneralOptions.canvasHeight,
      isLoading: isProcessingLocalFile,
      onFilesChange: handleFilesChange,
      translations: dropAreaTranslations,
      width: parsedGeneralOptions.canvasWidth
    })]
  });
};

export { CropModal };
