'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dateFns = require('date-fns');
var React = require('react');
var index = require('./index-7955fb8e.cjs.prod.js');
var types = require('./types-fd46a405.cjs.prod.js');
var tw = require('./tw-9929267e.cjs.prod.js');
var timepicker_input = require('./timepicker-input-2452d125.cjs.prod.js');
var timepicker_item = require('./timepicker-item-bd24c49d.cjs.prod.js');
var timepicker_listbox = require('./timepicker-listbox-a5eef117.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-e39057bd.cjs.prod.js');
var combobox = require('./combobox-61322389.cjs.prod.js');
var combobox_popover = require('./combobox-popover-a848a4b4.cjs.prod.js');
var inline_field = require('./inline-field-4863bb0f.cjs.prod.js');
var field = require('./field-8fcfe704.cjs.prod.js');
require('./tw-merge-885aa7a8.cjs.prod.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.prod.js');

const dateFormats = {
  hoursAndMinutes: 'HH:mm',
  timeWithMeridiem: 'h:mm a'
};
const regexPatterns = {
  /**
   * This pattern matches a time string in the format:
   *   - 1-12 hours (with or without leading zero)
   *   - Minutes from 00-59 (optional)
   *   - AM or PM (case insensitive, optional)
   *
   * Examples of valid inputs:
   *   - "12:45 PM"
   *   - "9:30am"
   *   - "3:15 Pm"
   *   - "5 AM"
   *   - "4 :32" (additional or no white space between hours minutes and meridian)
   *   - "1245" (colon optional)
   *   - "9"
   *
   * Examples of invalid inputs:
   *   - "13:00 PM" (hour greater than 12)
   *   - "10:70 AM" (minutes greater than 59)
   *   - "PM" (missing hour)
   */
  Hh12: /^(1[0-2]|0?[1-9])\s*:?(\s*[0-5][0-9])?\s*([AaPp][Mm])?$/,
  /**
   * This pattern matches a 24-hour time string in the format:
   *   - Hours from 00-23 (with or without leading zero)
   *   - Minutes from 00-59 (optional)
   *
   * Examples of valid inputs:
   *   - "12:45"
   *   - "09:30"
   *   - "3:15"
   *   - "17:00"
   *   - "15"
   *   - "22 45"
   *
   *
   * Examples of invalid inputs:
   *   - "24:00" (hour greater than 23)
   *   - "10:70" (minutes greater than 59)
   */
  Hh24: /^([01]?[0-9]|2[0-3])\s*:?(\s*[0-5][0-9])?$/,
  /**
   * This pattern matches any character that is NOT a digit (0-9) or an alphabet letter (a-z, A-Z).
   * The 'g' flag is used for global search, meaning it will match all occurrences in a string.
   *
   * Examples:
   *   - "abc123"   --> No match (all characters are alphanumeric)
   *   - "abc!@#123" --> Matches "!" and "@#" (non-alphanumeric characters)
   *   - "Hello_World!" --> Matches "_" and "!" (non-alphanumeric characters)
   *
   * Usage:
   *   const nonAlphanumericPattern = /[^0-9a-zA-Z]/g;
   *   const stringWithoutNonAlphanumeric = myString.replace(nonAlphanumericPattern, '');
   *   // This will remove all non-alphanumeric characters from 'myString'
   */
  SpecialCharacter: /[^0-9a-zA-Z]/g,
  /**
   * Matches a time string with optional minutes and AM/PM indicator.
   * Format examples:
   *   - "HH:MM AM/PM" or "H:MM AM/PM" (case insensitive)
   *   - "HH AM/PM" or "H AM/PM" (case insensitive)
   */
  AmPmOption: /(\d+)\s*:\s*(\d+)?\s*(am|pm)/i,
  /**
   * Matches a time string with optional AM/PM indicator.
   * Format examples:
   *   - "HH AM/PM" or "H AM/PM" (case insensitive)
   */
  WithMeridian: /^\d{1,2}\s*[ap]m$/i
};

/**
 * Creates a new `Date` object with the current date but with the time set to the hours and minutes
 * from the provided `date` object. This is useful for setting times while preserving the current date.
 *
 * @param {Date} date - The date object whose time (hours and minutes) will be used.
 * @returns {Date} A new `Date` object with the current date and the time set to the provided date's time.
 */
const createDateWithToday = date => {
  // Create a new Date object with the same date as today but the time from the provided date
  const today = new Date();
  return new Date(
  // ignore [current year month] from function args and use current date
  today.getFullYear(), today.getMonth(), today.getDate(),
  // set hours and minutes from the args
  date.getHours(), date.getMinutes());
};

/**
 * Adds custom time options to the list of generated times, excluding any that are invalid, fall
 * outside the specified range, or duplicate existing times. The custom options are added to the end
 * of the generated times array and then sorted in chronological order.
 *
 * @param {Date[]} customValues - An array of custom `Date` objects to be added to the generated times.
 * @param {string} timeFormat - The format string used to format the time (e.g., '12' for 12-hour format).
 * @param {Date | undefined} minDate - The minimum date (inclusive). Times equal to or less than this are excluded.
 * @param {Date | undefined} maxDate - The maximum date (inclusive). Times equal to or greater than this are excluded.
 * @param {TimeOption[]} generatedTimes - An array of already generated time options to avoid duplicates.
 * @returns {TimeOption[]} The updated list of time options including the newly added custom options, sorted in chronological order.
 */
const addCustomTimeOptions = ({
  customValues,
  timeFormat,
  minValue,
  maxValue,
  times,
  showDurationLabel
}) => {
  // Add custom options to the generatedTimes array
  times.push(
  // Spread the filtered and processed customValues array into generatedTimes
  ...customValues
  // Filter out invalid dates
  .filter(dateFns.isValid).map(date => {
    // Create a new Date object using the current date and custom hours and minutes
    return createDateWithToday(date);
  })
  // Filter out dates that are not within the allowed range and check for duplicates
  .filter(date =>
  // Exclude dates that are less than or equal to minDate
  (!minValue || date.getTime() > minValue.getTime()) && (
  // Exclude dates that are greater than or equal to maxDate
  !maxValue || date.getTime() < maxValue.getTime()) &&
  // Exclude dates that are already present in generatedTimes
  !times.some(timeOption => timeOption.time === dateFns.format(date, timeFormat)))
  // Map remaining valid dates to the required format
  .map(date => ({
    time: dateFns.format(date, timeFormat),
    // Format the date into a time string
    dateObject: date,
    // Include the original date object
    durationLabel: showDurationLabel && minValue ? formatDuration(minValue, date) : undefined
  })));

  // Return the updated list of time options sorted chronologically
  return times.sort((a, b) => a.dateObject.getTime() - b.dateObject.getTime());
};

/**
 * Calculate the start index for time intervals based on minDate.
 * @param {Date | undefined} minDate - The minimum date and time to start generating times. If undefined, starts from the beginning of the day.
 * @param {number} interval - The interval in minutes between each time option.
 * @returns {number} The calculated start index.
 */
const calculateStartIndex = (minDate, interval) => {
  return minDate ? Math.ceil((minutesSinceMidnight(minDate) + 1) / interval) : 0;
};

/**
 * Calculate the end index for time intervals based on maxDate.
 * @param {Date | undefined} maxDate - The maximum date and time to end generating times. If undefined, ends at the end of the day.
 * @param {number} interval - The interval in minutes between each time option.
 * @returns {number} The calculated end index.
 */
const calculateEndIndex = (maxDate, interval) => {
  // Calculate total intervals in a day
  const totalIntervals = 24 * 60 / interval;
  return maxDate ? Math.ceil(minutesSinceMidnight(maxDate) / interval) - 1 : totalIntervals - 1;
};

/**
 * Calculates the number of minutes since midnight for a given date.
 *
 * @param {Date} date - The date object to extract the time from.
 * @returns {number} - The total minutes since midnight.
 */
const minutesSinceMidnight = date => {
  // Get the number of hours and convert to minutes, then add the remaining minutes
  return date.getHours() * 60 + date.getMinutes();
};

/**
 * Parses a time string into hour, minute, and meridian (AM/PM).
 * @param timeString The input time string to parse.
 * @returns An array containing hour, minute, and meridian in that order.
 */
const parseHourAndMinute = timeString => {
  const match = timeString.match(/^(\d{1,2})(\d{2})?(am|pm)?$/i);
  if (match) {
    const hour = match[1] ? match[1].padStart(2, '0') : '';
    const minute = match[2] ? match[2] : '00';
    const meridian = match[3] ? match[3].toLowerCase() : 'am';
    return [hour, minute, meridian];
  }
  return ['', '', ''];
};

/**
 * Formats the duration between two dates into a human-readable string.
 *
 * Example:
 * ```
 * const startDate = new Date('2022-01-01T00:00:00');
 * const endDate = new Date('2022-01-01T01:30:00');
 * const durationString = formatDuration(startDate, endDate);
 * console.log(durationString); // Output: "1 hr 30 mins"
 * ```
 *
 * @param {Date} startDate - The start date.
 * @param {Date} endDate - The end date.
 * @returns {string} The formatted duration string.
 */
const formatDuration = (startDate, endDate) => {
  const diffInMinutes = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60));
  const hours = Math.floor(diffInMinutes / 60);
  const minutes = diffInMinutes % 60;

  // Construct the duration string based on hours and minutes
  const hourPart = hours > 0 ? `${hours} hr${hours > 1 ? 's' : ''}` : '';
  const minutePart = minutes > 0 ? `${minutes} min${minutes > 1 ? 's' : ''}` : '';

  // Combine parts, ensuring to handle cases where one part may be empty
  return [hourPart, minutePart].filter(Boolean).join(' ').trim();
};

/**
 * Removes special characters from a string and converts various time formats to a standardized format.
 * @param str The input string to process.
 * @returns A processed string with special characters removed or in a standardized time format.
 */
const removeSpecialChars = str => {
  str = str.trim();
  // Match various time formats and convert to standardized format
  const matchAMPM = str.match(regexPatterns.AmPmOption);
  if (matchAMPM) {
    const hour = matchAMPM[1] ? parseInt(matchAMPM[1]) : 0;
    const minute = matchAMPM[2] ? matchAMPM[2].padStart(2, '0') : '00';
    const period = matchAMPM[3] ? matchAMPM[3].toLowerCase() : undefined;
    return `${hour}${minute}${period}`;
  } else if (regexPatterns.WithMeridian.test(str)) {
    const hour = parseInt(str.substring(0, str.length - 2));
    const period = str.substring(str.length - 2).toLowerCase();
    return `${hour}00${period}`;
  }
  // If not in am/pm format, remove special characters
  return str.replace(regexPatterns.SpecialCharacter, '').toLowerCase();
};
const getFormat = timeFormat => {
  return timeFormat === '12' ? dateFormats.timeWithMeridiem : dateFormats.hoursAndMinutes;
};

/**
 * Generates an array of time options based on the specified time format, interval, and date range.
 *
 * @param {string} timeFormat - The format string for time representation (e.g., 'hh:mm a').
 * @param {number} interval - The interval in minutes between each time option.
 * @param {Date | undefined} minDate - The minimum date and time to start generating times. If undefined, starts from the beginning of the day.
 * @param {Date | undefined} maxDate - The maximum date and time to end generating times. If undefined, ends at the end of the day.
 * @returns {TimeOption[]} An array of `TimeOption` objects with formatted time strings and corresponding Date objects.
 */
const generateTimes = ({
  timeFormat,
  interval,
  minValue,
  maxValue,
  customValues,
  showDurationLabel
}) => {
  const today = new Date();
  const times = [];
  const startIndex = calculateStartIndex(minValue, interval);
  const endIndex = calculateEndIndex(maxValue, interval);

  // Generate times from startIndex to endIndex
  for (let index = startIndex; index <= endIndex; index++) {
    const totalMinutes = index * interval;
    const hour = Math.floor(totalMinutes / 60);
    const minute = totalMinutes % 60;
    const date = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hour, minute);

    // Format the date into the specified time format
    const timeString = dateFns.format(date, timeFormat);
    times.push({
      time: timeString,
      dateObject: date,
      durationLabel: showDurationLabel && minValue ? formatDuration(minValue, date) : undefined
    });
  }
  if (customValues && customValues.length > 0) {
    return addCustomTimeOptions({
      customValues,
      timeFormat,
      // set date for min and max Value to make sure it has today date there are possibilities that date object can be like this new Date(0,0,0,2,34)
      minValue: minValue ? createDateWithToday(minValue) : minValue,
      maxValue: maxValue ? createDateWithToday(maxValue) : maxValue,
      times,
      showDurationLabel
    });
  }
  return times;
};

/**
 * Validates and formats a time input based on a specified helper format.
 * @param input The input time string to validate and format.
 * @param helperFormat The helper format string to guide the validation and formatting (e.g., 'h:mm a' for 12-hour time with AM/PM).
 * @returns A TimeOption object with a formatted time string and corresponding Date object.
 */
const validateTimeFormat = (input, helperFormat) => {
  const defaultTime = {
    dateObject: new Date(),
    time: ''
  };
  input = input.trim();
  const timeFormatRegEx = helperFormat.includes('a') ? regexPatterns.Hh12 : regexPatterns.Hh24;
  const isValidInput = timeFormatRegEx.test(input);
  if (!isValidInput) return defaultTime;

  // Convert AM/PM to uppercase with space if missing, preserving extra spaces
  const correctedInput = input.replace(timeFormatRegEx, (__match, hour, minute, meridian) => {
    minute = minute || '00'; // Set default value '00' if minute is not available
    let formattedTime = `${parseInt(hour, 10).toString().padStart(2, '0')}:${parseInt(minute, 10).toString().padStart(2, '0')}`;

    // If 12-hour format and hour is 12, set to 0
    if (helperFormat.includes('a') && parseInt(hour, 10) === 12) {
      hour = '00';
    }

    // If meridian is provided, uppercase it
    if (meridian) {
      meridian = meridian.toUpperCase();
      formattedTime += ` ${meridian}`;
    }
    if (meridian === undefined && helperFormat === dateFormats.timeWithMeridiem) {
      meridian = 'AM';
      formattedTime += ` ${meridian}`;
    }
    return formattedTime;
  });
  const parsedDate = dateFns.parse(correctedInput, helperFormat, new Date());
  const formattedTime = dateFns.format(parsedDate, helperFormat);
  return {
    dateObject: parsedDate,
    time: formattedTime
  };
};

/**
 * Extracts time strings from an array of TimeOption objects and removes special characters.
 * @param times An array of TimeOption objects containing time strings.
 * @returns An array of extracted and cleaned time strings.
 */
const extractTimeStringArray = times => {
  const timesData = [];
  times.forEach(timeOption => {
    timesData.push(removeSpecialChars(timeOption.time.toLowerCase()));
  });
  return timesData;
};

/**
 * Finds the index of a time string within an array of time strings,
 * considering an optional prefix in the format "HHMMam" or "HHMMpm".
 * @param timeStringArr An array of time strings to search within.
 * @param prefix The prefix to match against the time strings (e.g., "12pm").
 * @returns The index of the matched time string in the array, or -1 if not found.
 */
const findIndexWithPrefix = (timeStringArr, prefix) => {
  const normalizedPrefix = removeSpecialChars(prefix.toLowerCase());

  // Check if the normalizedPrefix contains any digits
  const containsNumber = /\d/.test(normalizedPrefix);
  if (!containsNumber) {
    return -1; // Return -1 if there are no numbers in the prefix
  }
  const [inputHour, inputMinute, inputMeridian] = parseHourAndMinute(normalizedPrefix);
  const index = timeStringArr.findIndex(timeString => {
    const [hour, minute, meridian] = parseHourAndMinute(timeString);
    if (inputMinute !== undefined && inputMeridian !== undefined) {
      // If minute and meridian are provided, check for exact hour, minute, and meridian match
      return hour === inputHour && minute === inputMinute && meridian === inputMeridian;
    } else if (inputMinute !== undefined) {
      // If only minute is provided, check for exact hour and minute match
      return hour === inputHour && minute === inputMinute;
    } else {
      // If no minute is provided, check for exact hour and meridian match
      return hour === inputHour && meridian === inputMeridian;
    }
  });
  return index;
};

/**
 * getTimeOption - Utility function to create a TimeOption object from a Date object.
 * @param {Date} date The Date object from which to create the TimeOption.
 * @param {string} helperFormat The format string to format the time.
 * @returns {TimeOption} The TimeOption object containing the formatted time and the Date object.
 */
const getTimeOption = (date, helperFormat) => {
  const updatedDate = createDateWithToday(date);
  // Format the new Date object using the provided helperFormat
  const formattedTime = dateFns.format(updatedDate, helperFormat);

  // Return a new TimeOption object with the formatted time and the Date object
  return {
    time: formattedTime,
    dateObject: updatedDate
  };
};

/**
 * Determines the input state based on the provided dateObject, minValue, and maxValue.
 * @param date - The date object to be checked.
 * @param minValue - The minimum allowable date.
 * @param maxValue - The maximum allowable date.
 * @returns The corresponding TimePickerInputState.
 */
const getTimePickerInputState = (date, minValue, maxValue) => {
  if (!date) {
    return types.TimePickerInputState.EMPTY;
  }
  if (minValue && date <= minValue) {
    return types.TimePickerInputState.LTE_MIN;
  } else if (maxValue && date >= maxValue) {
    return types.TimePickerInputState.GTE_MAX;
  } else {
    return types.TimePickerInputState.VALID;
  }
};

/**
 * Generates an array of TimeOption objects from an array of custom day strings.
 * @param customDays - An array of strings representing custom days.
 * @returns An array of TimeOption objects corresponding to valid custom days.
 * @example
 * returns [{ time: 'Full Day', dateObject: new Date() }, { time: 'Half Day', dateObject: new Date() }]
 * getCustomDayOptions(['Full Day', 'Half Day']);
 */
const getCustomDayOptions = customDays => {
  return customDays.filter(day => day.trim() !== '') // Filter out empty or whitespace strings
  .map(day => ({
    time: day,
    dateObject: new Date()
  }));
};

const commonLabelStyles = tw.tw`tabular-nums whitespace-nowrap`;
const getTimePickerStyles = ({
  format,
  variant,
  isDurationEnabled
}) => ({
  durationLabel: tw.tw`
		text-body-10 
		text-secondary
	`,
  field: tw.tw`
		sm:w-20
		w-24 		
 	`,
  input: tw.tw`
		${fontStyleLookup[variant]}
  	`,
  popover: tw.tw`
		${isDurationEnabled ? minWidthLabelStyleLookup[format] : minWidthStyleLookup[format]}
		w-max	 	
	`,
  listbox: tw.tw`
  	 	flex 
	 	flex-col
	`,
  listboxItem: tw.tw`
		${commonLabelStyles}
	`,
  listboxItemCenter: tw.tw``,
  listboxItemEnd: tw.tw``,
  listboxItemStart: tw.tw``,
  timeSlot: tw.tw`
		${isDurationEnabled ? '' : timeSlotStylesLookup[format]}
		${displayStyleLookup[format]}
	`,
  timeSlotWrapper: tw.tw`
		flex
		gap-1
		items-baseline
	`,
  separator: tw.tw`
		border-t 
		border-tertiary 
		my-1
	`
});
const fontStyleLookup = {
  standard: 'sm:text-body-12',
  subtle: 'sm:text-body-14'
};
const timeSlotStylesLookup = {
  12: tw.tw`ms-auto me-1`,
  24: ''
};
const displayStyleLookup = {
  12: tw.tw`w-16 sm:w-14 text-right`,
  // maximum a slot value can be w-14
  24: ''
};
const minWidthStyleLookup = {
  12: 'min-w-[104px]',
  24: 'min-w-[92px]'
};
const minWidthLabelStyleLookup = {
  12: 'min-w-[174px]',
  24: 'min-w-[162px]'
};

const TimePicker = /*#__PURE__*/React.forwardRef(function TimePicker({
  className,
  classNames = {},
  clear = false,
  customValues,
  customDays,
  defaultValue,
  errorMessage,
  format = '12',
  interval = 60,
  isDisabled = false,
  label,
  labelVisibility = 'hidden',
  maxValue,
  minValue,
  onSelect,
  showDurationLabel = false,
  shouldUsePortal = true,
  style = {},
  styles = {},
  variant = 'standard'
}, forwardedRef) {
  const isDurationEnabled = !!(showDurationLabel && minValue);
  const parts = index.useComponentStyleParts({
    className,
    classNames,
    style,
    styles,
    tw: getTimePickerStyles({
      format,
      variant,
      isDurationEnabled
    })
  }, ['durationLabel', 'errorIcon', 'errorMessage', 'errorTrack', 'field', 'input', 'label', 'listbox', 'listboxItem', 'listboxItemCenter', 'listboxItemEnd', 'listboxItemStart', 'popover', 'separator', 'timeSlot', 'timeSlotWrapper']);
  const fieldStyleProps = {
    ...parts.field,
    classNames: {
      label: parts.label.className,
      errorMessage: parts.errorMessage.className,
      errorIcon: parts.errorIcon.className,
      errorTrack: parts.errorTrack.className
    },
    styles: {
      label: parts.label.style,
      errorMessage: parts.errorMessage.style,
      errorIcon: parts.errorIcon.style,
      errorTrack: parts.errorTrack.style
    }
  };
  const menuItemTrackStyleProps = {
    className: parts.listboxItem.className,
    classNames: {
      center: parts.listboxItemCenter.className,
      railStart: parts.listboxItemStart.className,
      railEnd: parts.listboxItemEnd.className
    },
    style: parts.listboxItem.style,
    styles: {
      center: parts.listboxItemCenter.style,
      railStart: parts.listboxItemStart.style,
      railEnd: parts.listboxItemEnd.style
    }
  };
  const [searchTerm, setSearchTerm] = React.useState('');
  const helperFormat = getFormat(format);
  const times = React.useMemo(() => generateTimes({
    timeFormat: helperFormat,
    interval,
    minValue,
    maxValue,
    customValues,
    showDurationLabel
  }), [helperFormat, interval, minValue, maxValue, customValues, showDurationLabel]);

  // Generate options for custom days.
  const dayOptions = React.useMemo(() => {
    return customDays !== null && customDays !== void 0 && customDays.length ? getCustomDayOptions(customDays) : [];
  }, [customDays]);

  // combine options to map the correct index of option in popover
  const combinedOptions = React.useMemo(() => {
    return [...dayOptions, ...times];
  }, [dayOptions, times]);
  const timeStringArr = React.useMemo(() => {
    return extractTimeStringArray(combinedOptions);
  }, [combinedOptions]);
  const getDefaultTimeOption = React.useCallback(defaultValue => {
    if (defaultValue === undefined || !dateFns.isValid(defaultValue)) {
      return undefined;
    }
    return getTimeOption(defaultValue, helperFormat);
  }, [helperFormat]);
  const [selectedOption, setSelectedOption] = React.useState(getDefaultTimeOption(defaultValue));
  const getIndex = React.useCallback(option => {
    return option ? combinedOptions.findIndex(time => time.time === option.time) : -1;
  }, [combinedOptions]);
  const [highlightedIndex, setHighlightedIndex] = React.useState(getIndex(selectedOption));
  const handleInputOnBlur = event => {
    event.stopPropagation();
    handleInputChange();
  };
  const handleInputChange = () => {
    if (searchTerm === '' || searchTerm === (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.time)) return;
    const timeObj = validateTimeFormat(searchTerm, helperFormat);
    const handleInvalidInput = () => {
      setSelectedOption(undefined);
      onSelect({
        newOption: undefined,
        inputState: types.TimePickerInputState.INVALID_FORMAT
      });
    };
    timeObj.time !== '' ? handleSelectionChange(timeObj) : handleInvalidInput();
  };
  const handleSelectionChange = option => {
    setSelectedOption(option);
    setSearchTerm('');
    option && setHighlightedIndex(getIndex(option));
    onSelect({
      newOption: option,
      inputState: getTimePickerInputState(option === null || option === void 0 ? void 0 : option.dateObject, minValue, maxValue)
    });
  };

  //Reset the selectedOption and Input
  React.useEffect(() => {
    if (clear) {
      setSelectedOption(undefined);
      setSearchTerm('');
      setHighlightedIndex(-1);
    }
  }, [clear]);

  // Effect to update highlightedIndex when searchterm updates
  React.useEffect(() => {
    if (searchTerm === '') {
      if (!selectedOption) setHighlightedIndex(-1);
      return;
    }
    // If searchTerm is not empty, find the index with prefix
    const index = findIndexWithPrefix(timeStringArr, searchTerm);
    setHighlightedIndex(index);
  }, [searchTerm, selectedOption, timeStringArr]);

  // Update selectedOption when defaultValue changes
  React.useEffect(() => {
    const defaultTimeOption = getDefaultTimeOption(defaultValue);
    setSelectedOption(defaultTimeOption);
    setSearchTerm('');
    setHighlightedIndex(getIndex(defaultTimeOption));
  }, [defaultValue, getDefaultTimeOption, getIndex]);
  const FieldComponent = variant === 'subtle' ? inline_field.InlineField : field.Field;
  return /*#__PURE__*/jsxRuntime.jsx(FieldComponent, {
    errorMessage: errorMessage,
    isDisabled: isDisabled,
    label: label,
    labelVisibility: labelVisibility,
    ...fieldStyleProps,
    children: /*#__PURE__*/jsxRuntime.jsxs(combobox.Combobox, {
      inputValue: searchTerm || (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.time),
      menuTrigger: "focus",
      onInputChange: setSearchTerm,
      onSelectionChange: handleSelectionChange,
      popoverMaxHeight: 205,
      selectedKey: "time",
      selectedOption: selectedOption,
      children: [/*#__PURE__*/jsxRuntime.jsx(timepicker_input.TimePickerInput, {
        onBlur: handleInputOnBlur,
        onEnterInputHandler: handleInputChange,
        placeholder: helperFormat,
        ref: forwardedRef,
        ...parts.input
      }), /*#__PURE__*/jsxRuntime.jsxs(combobox_popover.ComboboxPopover, {
        shouldUsePortal: shouldUsePortal,
        ...parts.popover,
        children: [(dayOptions === null || dayOptions === void 0 ? void 0 : dayOptions.length) > 0 ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsx(RenderTimePickerItems, {
            combinedOptions: combinedOptions,
            parts: parts,
            styleProps: menuItemTrackStyleProps,
            timeOptions: dayOptions
          }), /*#__PURE__*/jsxRuntime.jsx(box.Box, {
            as: "span",
            ...parts.separator,
            role: "separator"
          })]
        }) : null, /*#__PURE__*/jsxRuntime.jsx(timepicker_listbox.TimePickerListbox, {
          "data-highlighted-index": highlightedIndex,
          options: times,
          ...parts.listbox,
          children: /*#__PURE__*/jsxRuntime.jsx(RenderTimePickerItems, {
            combinedOptions: combinedOptions,
            parts: parts,
            styleProps: menuItemTrackStyleProps,
            timeOptions: times
          })
        })]
      })]
    })
  });
});
const RenderTimePickerItems = ({
  timeOptions,
  combinedOptions,
  styleProps,
  parts
}) => {
  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: timeOptions.map(option => /*#__PURE__*/jsxRuntime.jsx(timepicker_item.TimePickerItem, {
      id: option.time,
      option: option,
      timeOptions: combinedOptions,
      ...styleProps,
      children: /*#__PURE__*/jsxRuntime.jsxs(box.Box, {
        ...parts.timeSlotWrapper,
        children: [/*#__PURE__*/jsxRuntime.jsx(box.Box, {
          as: "span",
          ...parts.timeSlot,
          children: option.time
        }), option.durationLabel ? /*#__PURE__*/jsxRuntime.jsx(box.Box, {
          as: "span",
          ...parts.durationLabel,
          children: option.durationLabel
        }) : null]
      })
    }, option.time))
  });
};
TimePicker.displayName = 'TimePicker';

exports.TimePicker = TimePicker;
