'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var context = require('./context-fb7f9049.cjs.dev.js');
var composeId = require('./compose-id-8f0cde18.cjs.dev.js');
var utils = require('./utils-1d447d37.cjs.dev.js');
var popover = require('./popover-8c8f3261.cjs.dev.js');
var use_debounce_function = require('./use-debounce-function-faa579f2.cjs.dev.js');

const initialDropdownState = {
  activeDescendantIndex: -1,
  descendantCount: 0,
  descendantNodes: undefined,
  descendantSearchTerm: '',
  isMenuOpen: false,
  lastKeyPressTime: 0,
  selectedOptionId: undefined
};
function dropdownReducer(state, action) {
  const currentTime = new Date().getTime();
  switch (action.type) {
    case 'OPEN_MENU':
      {
        if (state.isMenuOpen) {
          return state; // No need to update state if the menu is already open
        }
        return {
          ...state,
          isMenuOpen: true,
          activeDescendantIndex: -1,
          descendantSearchTerm: ''
        };
      }
    case 'CLOSE_MENU':
      {
        if (!state.isMenuOpen) {
          return state; // No need to update state if the menu is already closed
        }

        // Avoid using initialDropdownState as it will reset lastKeyPressTime
        return {
          ...state,
          isMenuOpen: false,
          activeDescendantIndex: -1,
          descendantNodes: undefined,
          descendantCount: 0,
          descendantSearchTerm: '',
          // Preserve selection
          selectedOptionId: state.selectedOptionId
        };
      }
    case 'ACTIVATE_FIRST_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = utils.findFirstNonDisabledIndex(state.descendantNodes, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the first active non-disabled descendant
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : state; // we've checked all descendants, reached the end, all nodes are disabled - return state unchanged
      }
    case 'ACTIVATE_LAST_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = utils.findLastNonDisabledIndex(state.descendantNodes, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the last active non-disabled descendant
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : state; // we've checked all descendants, reached the start, all nodes are disabled - return state unchanged
      }
    case 'ACTIVATE_NEXT_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = utils.findNextNonDisabledIndex(state.descendantNodes, state.activeDescendantIndex, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the new active descendant index
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : {
          ...state,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        }; // If no active descendant is found, return the current state with updates
      }
    case 'ACTIVATE_PREVIOUS_DESCENDANT':
      {
        // early return if there are no descendants
        if (!state.descendantNodes || state.descendantCount === 0) {
          return state;
        }
        const index = utils.findPreviousNonDisabledIndex(state.descendantNodes, state.activeDescendantIndex, state.descendantCount);
        return index !== -1 ? {
          ...state,
          activeDescendantIndex: index,
          // Update the state with the new active descendant index
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        } : {
          ...state,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        }; // If no active descendant is found, return the current state with updates
      }
    case 'SELECT_ITEM':
      {
        // early return if the selected option is already selected
        if (state.selectedOptionId === action.payload.optionId) return state;
        return {
          ...state,
          selectedOptionId: action.payload.optionId
        };
      }
    case 'CLEAR_SELECTED_ITEM':
      {
        // early return if the selected option is already undefined
        if (!state.selectedOptionId) return state;
        return {
          ...state,
          selectedOptionId: undefined
        };
      }
    case 'SET_ACTIVE_DESCENDANT_INDEX':
      {
        // early return if the active index and selected option id are already set
        if (state.activeDescendantIndex === action.payload.activeIndex && state.selectedOptionId === action.payload.activeId) {
          return state;
        }
        return {
          ...state,
          activeDescendantIndex: action.payload.activeIndex,
          selectedOptionId: action.payload.activeId
        };
      }
    case 'SET_HIGHLIGHTED_INDEX':
      {
        // early return if the active index is already set
        if (state.activeDescendantIndex === action.payload.activeIndex) {
          return state;
        }
        return {
          ...state,
          activeDescendantIndex: action.payload.activeIndex
        };
      }
    case 'SET_DESCENDANT_NODES':
      {
        var _action$payload$nodes;
        // early return if the descendant nodes are same or menu is closed
        if (!state.isMenuOpen || state.descendantNodes === action.payload.nodes) return state;

        // update the state with the new descendant nodes
        return {
          ...state,
          descendantCount: ((_action$payload$nodes = action.payload.nodes) === null || _action$payload$nodes === void 0 ? void 0 : _action$payload$nodes.length) ?? 0,
          descendantNodes: action.payload.nodes,
          descendantSearchTerm: '',
          lastKeyPressTime: 0
        };
      }
    case 'UPDATE_DESCENDANT_SEARCH_TERM':
      {
        const {
          newState
        } = utils.updateDescendantSearchTerm({
          descendantNodes: state.descendantNodes,
          descendantCount: state.descendantCount,
          activeDescendantIndex: state.activeDescendantIndex,
          lastKeyPressTime: state.lastKeyPressTime,
          currentTime,
          eventKey: action.payload.eventKey,
          descendantSearchTerm: state.descendantSearchTerm
        });
        return {
          ...state,
          ...newState
        };
      }
    default:
      {
        throw new Error(`Unhandled action type: ${action.type}`);
      }
  }
}

/**
 * Hook that provides the values for the DropdownContext.
 */
function useDropdownContextValues({
  popoverMatchReferenceWidth = true,
  popoverMaxHeight = 300,
  popoverMaxWidth = 300,
  popoverOffset = 0,
  popoverPlacement = 'bottom-start',
  strategy = 'absolute'
}) {
  const [state, dispatch] = React.useReducer(dropdownReducer, initialDropdownState);
  const {
    activeDescendantIndex,
    descendantCount,
    descendantNodes,
    descendantSearchTerm,
    isMenuOpen,
    lastKeyPressTime,
    selectedOptionId
  } = state;
  const {
    baseId,
    listId,
    popoverId,
    triggerId,
    comboboxId
  } = useDropdownIds();
  const popover$1 = popover.usePopover({
    matchReferenceWidth: popoverMatchReferenceWidth,
    maxHeight: popoverMaxHeight,
    maxWidth: popoverMaxWidth,
    offset: popoverOffset,
    placement: popoverPlacement,
    isOpen: isMenuOpen,
    isPopoverAlwaysMounted: true,
    strategy
  });
  const openMenu = React.useCallback(() => dispatch({
    type: 'OPEN_MENU'
  }), []);
  const closeMenuAction = React.useCallback(() => {
    dispatch({
      type: 'CLOSE_MENU'
    });
  }, []);
  const debouncedCloseMenuAction = use_debounce_function.useDebounceFunction(closeMenuAction, 50);
  const closeMenu = React.useCallback(() => {
    // Check if referenceRef is an HTMLElement before attempting to focus it
    if (popover$1.referenceRef.current instanceof HTMLElement) {
      var _popover$referenceRef;
      // Focus the trigger button when closing the menu, but prevent scrolling
      (_popover$referenceRef = popover$1.referenceRef.current) === null || _popover$referenceRef === void 0 || _popover$referenceRef.focus({
        preventScroll: true
      });
    }
    debouncedCloseMenuAction();
  }, [debouncedCloseMenuAction, popover$1.referenceRef]);
  const toggleMenu = React.useCallback(() => {
    isMenuOpen ? closeMenu() : openMenu();
  }, [closeMenu, isMenuOpen, openMenu]);
  const goToFirstMenuItem = React.useCallback(() => dispatch({
    type: 'ACTIVATE_FIRST_DESCENDANT'
  }), []);
  const goToLastMenuItem = React.useCallback(() => dispatch({
    type: 'ACTIVATE_LAST_DESCENDANT'
  }), []);
  const goToPreviousMenuItem = React.useCallback(() => dispatch({
    type: 'ACTIVATE_PREVIOUS_DESCENDANT'
  }), []);
  const goToNextMenuItem = React.useCallback(() => dispatch({
    type: 'ACTIVATE_NEXT_DESCENDANT'
  }), []);
  const updateDescendantSearchTerm = React.useCallback(eventKey => {
    dispatch({
      type: 'UPDATE_DESCENDANT_SEARCH_TERM',
      payload: {
        eventKey
      }
    });
  }, []);
  const selectItem = React.useCallback(optionId => {
    dispatch({
      type: 'SELECT_ITEM',
      payload: {
        optionId
      }
    });
  }, []);
  const clearSelectedItem = React.useCallback(() => {
    dispatch({
      type: 'CLEAR_SELECTED_ITEM'
    });
  }, []);
  const clickSelectedItem = React.useCallback(() => {
    // Add check to ensure there are selectable items
    if (activeDescendantIndex === -1 || descendantCount === 0) return;

    // Ensure descendantNodes is not undefined and has items
    if (!utils.isNodeListOfHTMLElements(descendantNodes)) return;
    const activeDescendant = descendantNodes[activeDescendantIndex];

    // Ensure the active descendant is a valid HTMLElement before attempting to click
    if (!(activeDescendant instanceof HTMLElement)) return;

    // Click the active descendant
    activeDescendant.click();
  }, [activeDescendantIndex, descendantCount, descendantNodes]);
  const activeDescendantId = utils.getActiveDescendantId(state);
  const contextValue = React.useMemo(() => ({
    activeDescendantId,
    activeDescendantIndex,
    baseId,
    clearSelectedItem,
    clickSelectedItem,
    closeMenu,
    comboboxId,
    descendantCount,
    descendantNodes,
    descendantSearchTerm,
    dispatch,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem,
    isMenuOpen,
    lastKeyPressTime,
    listId,
    openMenu,
    popover: popover$1,
    popoverId,
    selectedOptionId,
    selectItem,
    toggleMenu,
    triggerId,
    updateDescendantSearchTerm
  }), [activeDescendantId, activeDescendantIndex, baseId, clearSelectedItem, clickSelectedItem, closeMenu, comboboxId, descendantCount, descendantNodes, descendantSearchTerm, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem, isMenuOpen, lastKeyPressTime, listId, openMenu, popover$1, popoverId, selectedOptionId, selectItem, toggleMenu, triggerId, updateDescendantSearchTerm]);
  return contextValue;
}

/**
 * Generates the ID of the dropdown's container element, trigger and popover
 * panel.
 *
 * These are generated together as they are connected by
 * aria-controls/aria-labelledby. The `baseId` prefix ensures that IDs are
 * unique so that multiple dropdowns can be placed on the same page.
 */
function useDropdownIds() {
  const id = React.useId();
  const baseId = `dropdown-${id}`;
  let triggerId;
  /**
   * It's OK to call useContext conditionally.
   * @see https://twitter.com/acdlite/status/1581401077915975680
   */
  try {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    triggerId = context.useFieldContext().controlId;
  } catch {
    triggerId = composeId.composeId(baseId, 'trigger');
  }
  return {
    baseId,
    listId: composeId.composeId(baseId, 'list'),
    popoverId: composeId.composeId(baseId, 'popover'),
    comboboxId: composeId.composeId(baseId, 'combobox'),
    triggerId
  };
}

exports.useDropdownContextValues = useDropdownContextValues;
