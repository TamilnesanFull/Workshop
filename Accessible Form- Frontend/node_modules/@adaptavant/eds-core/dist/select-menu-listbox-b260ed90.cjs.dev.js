'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var context = require('./context-1e651be3.cjs.dev.js');
var index = require('./index-3bdbdb42.cjs.dev.js');
var forwardRef = require('./forward-ref-6c731e6e.cjs.dev.js');
var mergeProps = require('./merge-props-74bd38ff.cjs.dev.js');
var styles = require('./styles-89d59f67.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var listbox = require('./listbox-c8a36196.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');
require('./cx-26784cbb.cjs.dev.js');
require('clsx');
require('./merge-ids-b19ec20e.cjs.dev.js');
require('./styles-3e350289.cjs.dev.js');
require('./tw-cabb7e4c.cjs.dev.js');
require('./styles-590374a3.cjs.dev.js');

const SelectMenuListbox = forwardRef.forwardRefWithGenericComponent(function SelectMenuListbox({
  children,
  className = '',
  classNames = {},
  options,
  style = {},
  styles: styles$1 = {},
  ...consumerProps
}, forwardedRef) {
  const {
    activeDescendantId,
    descendantNodes,
    dispatch,
    isMenuOpen,
    listId,
    triggerId
  } = context.useDropdownContext();
  const handleKeyDown = useKeydownNavigation();

  // Ref to track if the component has already been initialized
  const isFirstRenderRef = React.useRef(true);

  // When the dropdown is opened, the menu list should be focused in order for
  // the keyboard navigation to work.
  const autoFocusOnOpen = React.useCallback(node => {
    if (node && isMenuOpen && isFirstRenderRef.current) {
      node.focus({
        preventScroll: true
      });
    }
  }, [isMenuOpen]);

  /**
   * Sets the active descendant in the dropdown when the menu is open.
   * Finds the selected option within the popover and dispatches an action
   * to update the context with the index and ID of the active option.
   */
  React.useEffect(() => {
    if (!isMenuOpen || !descendantNodes || !isFirstRenderRef.current) return;
    const options = Array.from(descendantNodes);
    const activeOption = options.find(option => option.getAttribute('aria-selected') === 'true');
    if (activeOption) {
      dispatch({
        type: 'SET_ACTIVE_DESCENDANT_INDEX',
        payload: {
          activeIndex: options.indexOf(activeOption),
          activeId: activeOption.id
        }
      });
    }
    isFirstRenderRef.current = false;
  }, [descendantNodes, dispatch, isMenuOpen]);
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles: styles$1,
    tw: styles.getSelectMenuListboxStyles()
  });
  return /*#__PURE__*/jsxRuntime.jsx(listbox.Listbox, {
    ...mergeProps.mergeProps(consumerProps, {
      'aria-activedescendant': activeDescendantId,
      'aria-labelledby': triggerId,
      onKeyDown: handleKeyDown
    }),
    id: listId,
    options: options,
    ref: utils.mergeRefs(autoFocusOnOpen, forwardedRef),
    ...styleProps('root'),
    children: children
  });
});
function useKeydownNavigation() {
  const {
    clickSelectedItem,
    closeMenu,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem,
    updateDescendantSearchTerm
  } = context.useDropdownContext();
  return React.useCallback(event => {
    switch (event.code) {
      case 'ArrowUp':
        {
          event.preventDefault();
          goToPreviousMenuItem();
          return;
        }
      case 'ArrowDown':
        {
          event.preventDefault();
          goToNextMenuItem();
          return;
        }
      case 'Home':
        {
          event.preventDefault();
          goToFirstMenuItem();
          return;
        }
      case 'End':
        {
          event.preventDefault();
          goToLastMenuItem();
          return;
        }
      case 'Escape':
        {
          closeMenu();
          return;
        }
      case 'Enter':
      case 'Space':
        {
          event.preventDefault();
          clickSelectedItem();
          return;
        }
      case 'Tab':
        {
          closeMenu();
          return;
        }
      default:
        {
          // If the key is a letter, update the search term
          if (/^[a-zA-Z]{1}$/.test(event.key) &&
          // Bail if the user is holding a modifier key so they can use
          // keyboard shortcuts
          !event.metaKey && !event.ctrlKey) {
            event.preventDefault();
            updateDescendantSearchTerm(event.key);
            return;
          }
        }
    }
  }, [clickSelectedItem, closeMenu, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem, updateDescendantSearchTerm]);
}

exports.SelectMenuListbox = SelectMenuListbox;
