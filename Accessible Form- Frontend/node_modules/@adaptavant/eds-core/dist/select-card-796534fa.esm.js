'use client';
import { g as getStyleProps } from './index-dd10a77e.esm.js';
import { t as twMerge } from './tw-merge-91a8b6ee.esm.js';
import { m as mergeProps } from './merge-props-5c13cba9.esm.js';
import { t as tw } from './tw-c6a9a210.esm.js';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { createElement } from 'react';
import { B as Box } from './box-a5dda214.esm.js';
import { T as Text } from './text-3fc88ad6.esm.js';
import { L as Label } from './label-617d5123.esm.js';
import { R as RadioPrimitive } from './radio-primitive-fba710d2.esm.js';
import { useCombinedFocusContainerInputStyles, FocusContainer } from './focus-container-9b45fd51.esm.js';
import { CheckboxPrimitive } from './checkbox-primitive-7f83b97f.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';
import '@react-aria/utils';
import './cx-c5d68be6.esm.js';
import 'clsx';
import './merge-ids-c2d2d3d7.esm.js';
import './styles-267c9284.esm.js';
import './radio-control-icon-815a20cd.esm.js';
import './styles-53001919.esm.js';
import './align-child-to-text-c6521616.esm.js';

const getSelectCardStyles = ({
  isDisabled,
  orientation
}) => ({
  root: tw`
		${orientation === 'vertical' ? 'flex-col' : 'flex-row'}
		${selectCardVerticalSpaceClasses.gap}
		flex
		flex-wrap
	`,
  legend: tw`
		${isDisabled ? 'text-disabled' : ''}
		${selectCardVerticalSpaceClasses.marginBottom}
		sm:text-body-14
		text-body-16
	`,
  controlWrapper: tw`
		shrink-0
	`,
  directContentWrapper: tw`
		${orientation === 'vertical' ? 'flex-row justify-between' : 'flex-col justify-center'}
		flex
		gap-1
		grow
		h-full
		items-center
	`,
  dynamicContentWrapper: tw`
		duration-300
		mb-2
		overflow-hidden
		pe-2
		ps-8 #1
		transition-[height]
	`
  // #1 - 32px is derived from: 8px padding of the cardRow + 8px gap between control input to direct content + 16px size of input
});
const getCardStyles = ({
  isDisabled,
  orientation
}) => ({
  card: tw`
		${isDisabled ? 'text-disabled bg-neutral-disabled' : ''}
		min-h-9
		min-w-[154px]
		items-start
	`,
  cardRow: tw`
		${isDisabled ? 'cursor-default' : 'cursor-pointer'}
		${orientation === 'vertical' ? 'items-center' : 'items-start'}
		flex
		gap-2
		p-2
	`,
  focusIndicator: tw``
});

/**
 * The `<legend>` element doesn't participate in `<fieldset>`â€™s flex layout,
 * so we need to use margin instead to create vertical space between the legend
 * and the wrapper.
 * These classes are grouped together in an object to ensure they're always
 * using the same vertical space.
 */
const selectCardVerticalSpaceClasses = {
  gap: tw`gap-x-1 gap-y-2`,
  marginBottom: tw`mb-2`
};

/**
 * Compute the updated value of a control based on the checked state and the new value.
 * For checkboxes, if the control is checked, the new value is added to the existing value list.
 * If the control is unchecked and the value is an array, the new value is removed from the value list.
 * If the value is not an array and the control is unchecked, the value is returned as it is.
 * For radio buttons, the new value is returned as it is.
 *
 * @param controlType - The type of control ('checkbox' or 'radio')
 * @param checked - Whether the control is checked
 * @param value - The current value of the control
 * @param newValue - The new value to be added to the control
 * @returns The updated value of the control
 */
function computeUpdatedValue(controlType, checked, value, newValue) {
  if (controlType === 'checkbox') {
    if (checked) {
      return [...value, newValue]; // if its checked add the value to existing value list
    }
    if (Array.isArray(value)) {
      return value.filter(v => v !== newValue); // if its array "remove" the newValue from the value list (unchecked)
    }
    return value; // when value is not an array and not checked return the value as it is (don't alter the value as it should not happen)
  }
  return newValue; // For radio button, return the newValue as it is
}

function SelectCard({
  className = '',
  classNames = {},
  controlType = 'radio',
  isDisabled = false,
  legend,
  onChange,
  options,
  orientation = 'horizontal',
  style = {},
  styles = {},
  value,
  ...consumerProps
}) {
  const styleProps = getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getSelectCardStyles({
      isDisabled,
      orientation
    })
  });
  return /*#__PURE__*/jsxs(Box, {
    as: "fieldset",
    ...styleProps('root'),
    ...consumerProps,
    children: [legend ? /*#__PURE__*/jsx(Text, {
      as: "legend",
      ...styleProps('legend'),
      children: legend
    }) : null, options.map(option => {
      const {
        value: optionValue,
        directSlot,
        dynamicSlot,
        transitionHeightClass,
        ...restInputProps
      } = option;
      const isChecked = value === null || value === void 0 ? void 0 : value.includes(optionValue);
      const disabled = option.isDisabled || isDisabled;

      // To fetch styles for each card based on its disabled state
      const optionStyleProps =
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useCombinedFocusContainerInputStyles({
        className: '',
        // nullify the className(root) passed by consumer - classNames (cardRow) is enough
        classNames,
        style,
        styles,
        isDisabled: disabled,
        isInvalid: false,
        tw: getCardStyles({
          isDisabled: disabled,
          orientation
        })
      });
      const labelStyles = mergeProps(optionStyleProps('root'),
      // focus-container/styles.ts -> control part
      optionStyleProps('cardRow') // SelectCard/styles.ts -> cardRow part
      );
      return /*#__PURE__*/createElement(FocusContainer, {
        ...optionStyleProps('card'),
        classNames: {
          center: 'h-full',
          focusIndicator: {
            ...optionStyleProps('focusIndicator')
          }.className
        },
        isDisabled: disabled,
        isInvalid: false // we don't have invalid state for select card
        ,
        key: option.value,
        styles: {
          focusIndicator: {
            ...optionStyleProps('focusIndicator').style
          }
        }
      }, ({
        ref
      }) => {
        const controlInputProps = {
          // allow consumer to pass any other props (even ones not defined in the SelectCardOptionProps - but valid ones) to the input element,
          ...restInputProps,
          // define props required for functionality (like onChange, value, checked, etc) shouldn't override the consumer props
          checked: isChecked,
          isDisabled: disabled,
          ref,
          value: optionValue,
          onChange: ({
            target: {
              checked,
              value: newValue
            }
          }) => {
            if (disabled) return;
            const updatedValue = computeUpdatedValue(controlType, checked, value, newValue);
            onChange(updatedValue); // call the onChange function with updated value
          },
          ...styleProps('controlWrapper') // Targets root part(AlignChildToText) of primitives.
        };
        return /*#__PURE__*/jsxs(Fragment, {
          children: [/*#__PURE__*/jsxs(Label, {
            ...labelStyles,
            children: [controlType === 'checkbox' ? /*#__PURE__*/jsx(CheckboxPrimitive, {
              ...controlInputProps
            }) : /*#__PURE__*/jsx(RadioPrimitive, {
              ...controlInputProps
            }), directSlot ? /*#__PURE__*/jsx(Box, {
              ...styleProps('directContentWrapper'),
              className: twMerge(styleProps('directContentWrapper').className, orientation === 'horizontal' && !dynamicSlot ? '-ms-6' : ''),
              children: directSlot
            }) : null]
          }), dynamicSlot ? /*#__PURE__*/jsx(Box, {
            ...styleProps('dynamicContentWrapper'),
            className: twMerge(styleProps('dynamicContentWrapper').className, isChecked ? transitionHeightClass : `h-0 my-0`),
            children: isChecked ? dynamicSlot : null
          }) : null]
        });
      });
    })]
  });
}

export { SelectCard };
