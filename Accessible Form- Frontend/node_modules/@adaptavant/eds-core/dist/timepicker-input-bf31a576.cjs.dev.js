'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var context$1 = require('./context-1e651be3.cjs.dev.js');
var mergeProps = require('./merge-props-74bd38ff.cjs.dev.js');
var combobox_search_input = require('./combobox-search-input-520989b4.cjs.dev.js');
var context = require('./context-1d59120d.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var text_input = require('./text-input-ace7389d.cjs.dev.js');
var context$2 = require('./context-fb7f9049.cjs.dev.js');
require('./cx-26784cbb.cjs.dev.js');
require('clsx');
require('./merge-ids-b19ec20e.cjs.dev.js');

const TimePickerInput = /*#__PURE__*/React.forwardRef(function TimePickerInput(props, forwardedRef) {
  const {
    inputProps
  } = useTimePickerInput(props);
  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(text_input.TextInput, {
      ...inputProps,
      ref: forwardedRef
    }), /*#__PURE__*/jsxRuntime.jsx(combobox_search_input.LiveRegion, {})]
  });
});
function useTimePickerInput(props) {
  const {
    onEnterInputHandler,
    ...restProps
  } = props;
  const {
    inputValue = '',
    // Set inputValue to an empty string to prevent uncontrolled to controlled input warning. More info: https://reactjs.org/link/uncontrolled-to-controlled
    menuTrigger,
    onInputChange,
    onSelectionChange
  } = context.useCombobox();
  const {
    activeDescendantId,
    activeDescendantIndex,
    isMenuOpen,
    listId,
    popover,
    openMenu,
    closeMenu,
    clearSelectedItem
  } = context$1.useDropdownContext();
  const {
    isDisabled
  } = context$2.useFieldContext();
  const NavigateToBlur = () => {
    if (activeDescendantIndex === -1) {
      onEnterInputHandler();
      if (isMenuOpen) closeMenu();
    }
  };
  const handleChange = React.useCallback(event => {
    if (!isMenuOpen) openMenu();
    if (onInputChange) onInputChange(event.target.value);
    if (event.target.value === '') {
      clearSelectedItem();
      if (onSelectionChange) {
        onSelectionChange(undefined);
      }
    }
  }, [clearSelectedItem, isMenuOpen, onInputChange, onSelectionChange, openMenu]);
  const handleFocus = React.useCallback(() => {
    if (menuTrigger === 'focus') openMenu();
  }, [menuTrigger, openMenu]);
  const referenceProps = popover.getReferenceProps();
  const handleKeyDown = combobox_search_input.useKeydownNavigation(NavigateToBlur);
  const isAppleDevice = utils.isAppleDevice();
  const a11yProps = React.useMemo(() => ({
    'aria-activedescendant': isAppleDevice ? undefined : activeDescendantId,
    'aria-autocomplete': 'list',
    'aria-controls': listId,
    'aria-expanded': isMenuOpen,
    'aria-haspopup': 'listbox',
    autoComplete: 'off',
    autoCorrect: 'off',
    spellCheck: 'false',
    role: 'combobox'
  }), [activeDescendantId, isAppleDevice, isMenuOpen, listId]);
  const comboboxProps = React.useMemo(() => ({
    onKeyDown: isDisabled ? undefined : handleKeyDown,
    onChange: handleChange,
    onFocus: isDisabled ? undefined : handleFocus,
    value: inputValue
  }), [isDisabled, handleKeyDown, handleChange, handleFocus, inputValue]);
  return {
    inputProps: React.useMemo(() => ({
      ...mergeProps.mergeProps(restProps, a11yProps, comboboxProps),
      focusContainerRef: referenceProps.ref
    }), [restProps, a11yProps, comboboxProps, referenceProps.ref])
  };
}

exports.TimePickerInput = TimePickerInput;
