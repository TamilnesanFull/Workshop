'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var styles$1 = require('./styles-3786e407.cjs.prod.js');
var styles = require('./styles-291d4f6c.cjs.prod.js');
var tw = require('./tw-9929267e.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var text = require('./text-a5ab226e.cjs.prod.js');
var zeroWidthSpace = require('./zero-width-space-59cc78a9.cjs.prod.js');
var box = require('./box-e39057bd.cjs.prod.js');
var context = require('./context-008fcad0.cjs.prod.js');
var focus_container = require('./focus-container-be948f3e.cjs.prod.js');
require('./index-7955fb8e.cjs.prod.js');
require('./tw-merge-885aa7a8.cjs.prod.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.prod.js');

const getGhostInputStyles = ({
  hasAdornmentEnd,
  hasAdornmentStart,
  size
}) => ({
  root: tw.tw`
		${styles.inputHeightStylesLookup[size]}
		${styles.inputPaddingStylesLookup['end'][hasAdornmentEnd ? 'withAdornment' : 'withoutAdornment'][size]}
		${styles.inputPaddingStylesLookup['start'][hasAdornmentStart ? 'withAdornment' : 'withoutAdornment'][size]}
		${styles$1.typography[size]}
		aria-disabled:text-disabled
		bg-transparent
		flex
		leading-8
		text-primary
		[outline:none]
		w-full
	`,
  adornmentEnd: tw.tw`
		${styles$1.typography[size]}
		flex
		items-center
	`,
  adornmentStart: tw.tw`
		${styles$1.typography[size]}
		flex
		items-center
	`
});

/**
 * GhostInput
 *
 * @deprecated Field and InlineField now expose a variant via context.
 * (e.g. TextInput nested inside of an InlineField with be receive the 'subtle' variant).
 */
const GhostInput = /*#__PURE__*/React.forwardRef(function GhostInput({
  adornmentEnd,
  adornmentStart,
  className = '',
  classNames = {},
  style = {},
  styles = {},
  type = 'text',
  ...consumerProps
}, forwardedRef) {
  const {
    isDisabled,
    isInvalid,
    isRequired,
    size
  } = context.useFieldContext();
  const a11yProps = context.useInputA11yProps({
    isDisabled,
    isInvalid,
    isRequired
  });
  const styleProps = focus_container.useCombinedFocusContainerInputStyles({
    className,
    classNames,
    isDisabled,
    isInvalid,
    style,
    styles,
    tw: getGhostInputStyles({
      hasAdornmentEnd: Boolean(adornmentEnd),
      hasAdornmentStart: Boolean(adornmentStart),
      isInvalid,
      size
    })
  });
  const handleKeyDown = React.useCallback(event => {
    if (isDisabled && event.key !== 'Tab') {
      event.preventDefault();
    }
  }, [isDisabled]);
  return /*#__PURE__*/jsxRuntime.jsx(focus_container.FocusContainer, {
    adornmentEnd: adornmentEnd ? /*#__PURE__*/jsxRuntime.jsxs(text.Text, {
      ...styleProps('adornmentEnd'),
      children: [/*#__PURE__*/jsxRuntime.jsx(zeroWidthSpace.ZeroWidthSpace, {}), adornmentEnd]
    }) : undefined,
    adornmentStart: adornmentStart ? /*#__PURE__*/jsxRuntime.jsxs(text.Text, {
      ...styleProps('adornmentEnd'),
      children: [/*#__PURE__*/jsxRuntime.jsx(zeroWidthSpace.ZeroWidthSpace, {}), adornmentStart]
    }) : undefined,
    isDisabled: isDisabled,
    isGhost: true,
    isInvalid: isInvalid,
    children: ({
      ref
    }) => /*#__PURE__*/jsxRuntime.jsx(box.Box, {
      ...consumerProps,
      ...a11yProps,
      as: "input",
      onKeyDown: handleKeyDown,
      ref: utils.mergeRefs(ref, forwardedRef),
      type: type,
      ...styleProps('root')
    })
  });
});

exports.GhostInput = GhostInput;
