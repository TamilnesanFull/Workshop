'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var index = require('./index-7955fb8e.cjs.prod.js');
var tw = require('./tw-9929267e.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-e39057bd.cjs.prod.js');
var track = require('./track-f65e0bbd.cjs.prod.js');
require('./tw-merge-885aa7a8.cjs.prod.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.prod.js');

/**
 * Determines if a number is a floating-point number.
 * @param number - The number to check.
 * @returns True if the number has a decimal part; otherwise, false.
 * @example
 * isFloat(3.7) // Output: true
 * isFloat(3) // Output: false
 * isFloat(1.0) // Output: false
 */
const isFloat = number => !Number.isInteger(number);

/**
 * Gets the number of decimal places in a number.
 * @param number - The number to analyze.
 * @returns The count of decimal places.
 * @example
 * getDecimalPlaces(1.23) // Output: 2
 * getDecimalPlaces(1) // Output: 0
 */
const getDecimalPlaces = number => {
  if (Math.floor(number) === number) return 0;
  const decimalPart = number.toString().split('.')[1];
  return decimalPart ? decimalPart.length : 0;
};

/**
 * Calculates the maximum decimal precision based on step, min, and max values.
 * @param step - The step increment.
 * @param min - The minimum value.
 * @param max - The maximum value.
 * @returns The highest decimal precision among the provided inputs.
 * @example
 * calculateMaxPrecision(0.1, 0, 10) // Output: 1
 * calculateMaxPrecision(0.01, 0, 10) // Output: 2
 */
const calculateMaxPrecision = (step, min, max) => Math.max(getDecimalPlaces(step), getDecimalPlaces(min), getDecimalPlaces(max));

/**
 * Rounds a number to the nearest increment of a specified step.
 * @param number - The number to round.
 * @param step - The increment to which `number` should be rounded.
 * @returns The rounded number.
 * @example
 * roundToStep(3.7, 1) // Output: 4
 * roundToStep(3.7, 0.5) // Output: 3.5
 */
const roundToStep = (number, step) => {
  // If the step is a decimal number (e.g., 0.1, 0.5)
  if (isFloat(step)) {
    // Convert decimal step to whole number by finding inverse
    // Example: if step is 0.5, inverse is 1/0.5 = 2
    const inverse = 1 / step;

    // Multiply by inverse to work with whole numbers, round, then divide to get back to original scale
    // Example: number=3.7, step=0.5
    // 3.7 * 2 = 7.4
    // Math.round(7.4) = 7
    // 7 / 2 = 3.5
    return Math.round(number * inverse) / inverse;
  }

  // For whole number steps, simply divide, round, and multiply
  // Example: number=3.7, step=2
  // 3.7/2 = 1.85
  // Math.round(1.85) = 2
  // 2 * 2 = 4
  return Math.round(number / step) * step;
};

/**
 * Calculates the width percentage for a slider based on the current value.
 * @param params - The parameters for calculating width percentage
 * @param params.value - The current value of the slider
 * @param params.min - The minimum value
 * @param params.max - The maximum value
 * @param params.step - The step increment
 * @returns The percentage width of the slider's fill, clamped between 0 and 100
 * @example
 * calculateWidthPercentage({ value: 50, min: 0, max: 100, step: 1 }) // Output: 50
 * calculateWidthPercentage({ value: 150, min: 0, max: 100, step: 1 }) // Output: 100
 */
const calculateWidthPercentage = ({
  value,
  min,
  max,
  step
}) => {
  const maxPrecision = calculateMaxPrecision(step, min, max);
  const percentage = (value - min) / (max - min) * 100;
  const clampedPercentage = Math.max(0, Math.min(percentage, 100));
  return isFloat(clampedPercentage) ? Number(clampedPercentage.toFixed(maxPrecision)) : clampedPercentage;
};

/**
 * Calculates the new value based on the pointer's position on the slider track.
 * @param params - The parameters for calculating new position
 * @param params.clientX - The pointer's X coordinate
 * @param params.sliderRect - The bounding rectangle of the slider track
 * @param params.min - The minimum slider value
 * @param params.max - The maximum slider value
 * @param params.step - The step increment
 * @returns The value corresponding to the pointer's position
 * @example
 * // Assuming sliderRect = { left: 0, width: 200 }
 * calculateNewPosition({ clientX: 100, sliderRect, min: 0, max: 100, step: 1 }) // Output: 50
 */
const calculateNewPosition = ({
  clientX,
  sliderRect,
  min,
  max,
  step
}) => {
  const {
    left,
    width
  } = sliderRect;
  const maxPrecision = calculateMaxPrecision(step, min, max);
  const percentage = (clientX - left) / width;
  const clampedPercentage = Math.min(Math.max(percentage, 0), 1);
  const newValue = min + clampedPercentage * (max - min);
  const roundedValue = roundToStep(newValue, step);
  return isFloat(roundedValue) ? Number(roundedValue.toFixed(maxPrecision)) : roundedValue;
};

/**
 * Clamps a value within the specified min and max bounds, rounded to the nearest step.
 * @param params - The parameters for clamping value
 * @param params.value - The value to clamp
 * @param params.min - The minimum value
 * @param params.max - The maximum value
 * @param params.step - The step increment
 * @returns The clamped and rounded value
 * @example
 * getClampedValue({ value: 50, min: 0, max: 100, step: 1 }) // Output: 50
 * getClampedValue({ value: 3.7, min: 0, max: 10, step: 0.5 }) // Output: 3.5
 */
const getClampedValue = ({
  value,
  min,
  max,
  step
}) => {
  const maxPrecision = calculateMaxPrecision(step, min, max);
  const roundedValue = roundToStep(value, step);
  const clampedValue = Math.max(min, Math.min(max, roundedValue));
  return isFloat(clampedValue) ? Number(clampedValue.toFixed(maxPrecision)) : clampedValue;
};

/**
 * Updates the current slider value based on keyboard input.
 * @param options - Object containing keyboard input and slider parameters.
 * @param options.key - The keyboard key pressed.
 * @param options.currentValue - The current slider value.
 * @param options.step - The step increment.
 * @param options.min - The minimum value.
 * @param options.max - The maximum value.
 * @returns The new slider value.
 * @example
 * updateCurrentValue({ key: 'ArrowRight', currentValue: 50, step: 1, min: 0, max: 100 }) // Output: 51
 * updateCurrentValue({ key: 'Home', currentValue: 50, step: 1, min: 0, max: 100 }) // Output: 0
 */
const updateCurrentValue = ({
  key,
  currentValue,
  step,
  min,
  max
}) => {
  // Number of steps to move when using Page Up/Down
  const PAGE_STEP_MULTIPLIER = 5;
  switch (key) {
    case 'ArrowRight':
    case 'ArrowUp':
      return currentValue + step;
    case 'ArrowLeft':
    case 'ArrowDown':
      return currentValue - step;
    case 'Home':
      return min;
    case 'End':
      return max;
    case 'PageUp':
      // Page Up/Down keys move content by larger increments than arrow keys
      return currentValue + step * PAGE_STEP_MULTIPLIER;
    case 'PageDown':
      return currentValue - step * PAGE_STEP_MULTIPLIER;
    default:
      return currentValue;
  }
};

/**
 * Generates accessibility properties for the slider component.
 * @param props - Object containing slider accessibility-related properties.
 * @param props.isDisabled - If true, disables interaction.
 * @param props.ariaLabelledBy - ID of the label element for accessibility.
 * @param props.maxValue - Maximum value of the slider.
 * @param props.minValue - Minimum value of the slider.
 * @param props.value - Current value of the slider.
 * @returns Accessibility properties for the slider.
 */
const getAccessibilityProps = ({
  isDisabled,
  ariaLabelledBy,
  maxValue,
  minValue,
  value
}) => {
  return {
    role: 'slider',
    'aria-disabled': isDisabled || undefined,
    'aria-labelledby': ariaLabelledBy,
    'aria-valuemax': maxValue,
    'aria-valuemin': minValue,
    'aria-valuenow': value,
    tabIndex: isDisabled ? -1 : 0
  };
};

const getSliderStyles = ({
  isDisabled
}) => ({
  root: tw.tw`
		gap-3
		touch-none
		w-full
	`,
  baseArea: tw.tw`
		${isDisabled ? 'bg-neutral-disabled' : 'bg-neutral-tertiary'}
		h-[3px]
		rounded-8px 
		w-full 
	`,
  container: tw.tw`	
		flex		
		h-4		
		items-center
		relative		
	`,
  filledArea: tw.tw`
		${isDisabled ? 'bg-neutral-tertiary' : 'bg-inverse'}
		absolute
		h-[3px]
	`,
  thumb: tw.tw`
		${getThumbStyles(isDisabled)}
		absolute	
		focus:outline-none
		h-3
		w-3
		rounded-16px
		top-1/2
		start-0
		-translate-x-1/2
		-translate-y-1/2
	`,
  adornmentStart: tw.tw``,
  adornmentEnd: tw.tw``
});
function getThumbStyles(isDisabled) {
  return tw.tw`
		${isDisabled ? 'bg-neutral-tertiary cursor-default' : 'bg-inverse cursor-pointer focus:bg-inverse-pressed focus:shadow-50 hover:bg-inverse-hover hover:shadow-50'}
	`;
}

/**
 * Handles events and state management for the Slider component.
 * @param minValue - The minimum allowed value for the slider.
 * @param maxValue - The maximum allowed value for the slider.
 * @param step - The step increment for the slider.
 * @param controlledValue - If provided, the slider operates as a controlled component.
 * @param internalValue - The current internal value of the slider when uncontrolled.
 * @param onValueChange - Callback fired when the slider value changes.
 * @param setInternalValue - Function to update the internal state value.
 * @param sliderRef - RefObject to the slider element.
 * @param thumbRef - RefObject to the thumb element.
 * @returns An object with event handlers and a dragging state.
 */
const useSliderEvents = ({
  minValue,
  maxValue,
  step,
  controlledValue,
  internalValue,
  onValueChange,
  setInternalValue,
  sliderRef,
  thumbRef
}) => {
  const [isDragging, setIsDragging] = React.useState(false);

  // Updates the slider value, clamping it within min and max bounds
  const handleChange = React.useCallback(newValue => {
    const clampedValue = getClampedValue({
      value: newValue,
      min: minValue,
      max: maxValue,
      step
    });
    if (controlledValue === undefined) {
      setInternalValue(clampedValue);
    }
    if (onValueChange) {
      onValueChange(clampedValue);
    }
  }, [minValue, maxValue, step, controlledValue, onValueChange, setInternalValue]);

  // Updates the slider value based on the pointer's position
  const updateValueFromPosition = React.useCallback(clientX => {
    if (!sliderRef.current) return;
    const newValue = calculateNewPosition({
      clientX,
      sliderRect: sliderRef.current.getBoundingClientRect(),
      min: minValue,
      max: maxValue,
      step
    });
    handleChange(newValue);
  }, [maxValue, minValue, step, handleChange, sliderRef]);

  // Updates the slider position when dragging
  const handlePointerMove = React.useCallback(e => {
    if (!isDragging) return;
    requestAnimationFrame(() => {
      updateValueFromPosition(e.clientX);
    });
  }, [isDragging, updateValueFromPosition]);

  // Stops dragging when the pointer is released
  const handlePointerUp = React.useCallback(() => {
    setIsDragging(false);
  }, []);

  // Initiates dragging and updates position on pointer down
  const handlePointerDown = React.useCallback(e => {
    if (e.pointerType === 'touch' || e.pointerType === 'mouse') {
      // Ensure pointer events continue to be captured by this element even if the pointer moves outside
      // This is crucial for maintaining smooth dragging behavior when the user moves the cursor quickly
      e.currentTarget.setPointerCapture(e.pointerId);
      setIsDragging(true);
      handlePointerMove(e.nativeEvent);
    }
  }, [handlePointerMove]);

  // Updates the slider value on click
  const handleClick = React.useCallback(e => {
    var _thumbRef$current;
    updateValueFromPosition(e.clientX);
    // Ensure the thumb receives focus when the active state is triggered via the track.
    (_thumbRef$current = thumbRef.current) === null || _thumbRef$current === void 0 || _thumbRef$current.focus();
  }, [updateValueFromPosition, thumbRef]);

  // Handles keyboard navigation
  const handleKeyDown = React.useCallback(e => {
    e.preventDefault(); // Prevent browser back/forward navigation
    const currentValue = controlledValue !== undefined ? controlledValue : internalValue ?? minValue;
    const newValue = updateCurrentValue({
      key: e.key,
      currentValue,
      step,
      min: minValue,
      max: maxValue
    });
    if (newValue !== currentValue) handleChange(newValue);
  }, [controlledValue, internalValue, minValue, step, maxValue, handleChange]);

  // Sets up and cleans up pointer event listeners
  React.useEffect(() => {
    const slider = sliderRef.current;
    if (isDragging && slider) {
      slider.addEventListener('pointermove', handlePointerMove);
      slider.addEventListener('pointerup', handlePointerUp);
      return () => {
        slider.removeEventListener('pointermove', handlePointerMove);
        slider.removeEventListener('pointerup', handlePointerUp);
      };
    }
  }, [isDragging, handlePointerMove, handlePointerUp, sliderRef]);
  return {
    handlers: {
      handleClick,
      handleKeyDown,
      handlePointerDown
    },
    isDragging
  };
};

/**
 * Custom hook to validate the properties of a slider component.
 * Ensures `minValue`, `maxValue`, `step`, `defaultValue`, and `value` are within
 * acceptable bounds and provides feedback if any property is invalid.
 *
 * @param defaultValue - Optional initial value for the slider.
 * @param minValue - The minimum value allowed for the slider.
 * @param maxValue - The maximum value allowed for the slider.
 * @param step - The increment step for slider movement.
 * @param value - Optional controlled value for the slider.
 * @returns An object containing:
 *          - `isValid`: Indicates whether all properties are valid.
 *          - `errorMessage`: A descriptive message if a property is invalid.
 */
function useSliderValidation({
  defaultValue,
  minValue,
  maxValue,
  step,
  value
}) {
  const validationResult = React.useMemo(() => {
    // Check if minValue is less than maxValue
    if (minValue >= maxValue) {
      return {
        isValid: false,
        errorMessage: 'minValue must be less than maxValue'
      };
    }

    // Validate step is positive and within the range
    if (step <= 0 || step > maxValue - minValue) {
      return {
        isValid: false,
        errorMessage: 'step must be greater than 0 and within range'
      };
    }

    // Validate defaultValue is within min and max range
    if (defaultValue !== undefined && (defaultValue < minValue || defaultValue > maxValue)) {
      return {
        isValid: false,
        errorMessage: 'defaultValue must be between minValue and maxValue'
      };
    }

    // Validate value is within min and max range
    if (value !== undefined && (value < minValue || value > maxValue)) {
      return {
        isValid: false,
        errorMessage: 'value must be between minValue and maxValue'
      };
    }

    // If all validations pass
    return {
      isValid: true,
      errorMessage: ''
    };
  }, [defaultValue, minValue, maxValue, step, value]);
  return validationResult;
}

const Slider = /*#__PURE__*/React.forwardRef(function Slider({
  adornmentStart,
  adornmentEnd,
  ariaLabelledBy,
  className = '',
  classNames = {},
  isDisabled = false,
  maxValue = 100,
  minValue = 0,
  defaultValue,
  onValueChange,
  step = 1,
  style = {},
  styles = {},
  value: controlledValue,
  ...consumerProps
}, forwardedRef) {
  const sliderRef = React.useRef(null);
  const thumbRef = React.useRef(null);
  const [internalValue, setInternalValue] = React.useState(defaultValue ?? minValue);
  const value = controlledValue ?? internalValue;
  const {
    isDragging,
    handlers
  } = useSliderEvents({
    minValue,
    maxValue,
    step,
    controlledValue,
    internalValue,
    onValueChange,
    setInternalValue,
    sliderRef,
    thumbRef
  });
  const widthPercentage = React.useMemo(() => calculateWidthPercentage({
    value,
    min: minValue,
    max: maxValue,
    step
  }), [value, minValue, maxValue, step]);
  const a11yProps = getAccessibilityProps({
    isDisabled,
    ariaLabelledBy,
    maxValue,
    minValue,
    value
  });
  const parts = index.useComponentStyleParts({
    className,
    classNames,
    style,
    styles,
    tw: getSliderStyles({
      isDisabled
    })
  }, ['root', 'baseArea', 'container', 'filledArea', 'thumb', 'adornmentStart', 'adornmentEnd']);
  const sliderStyleProps = {
    ...parts.root,
    classNames: {
      railEnd: parts.adornmentEnd.className,
      railStart: parts.adornmentStart.className
    },
    styles: {
      railEnd: parts.adornmentEnd.style,
      railStart: parts.adornmentStart.style
    }
  };
  const validationResult = useSliderValidation({
    defaultValue,
    minValue,
    maxValue,
    step,
    value: controlledValue
  });
  if (!validationResult.isValid) {
    // eslint-disable-next-line no-console
    console.error(validationResult.errorMessage);
    return null;
  }
  return /*#__PURE__*/jsxRuntime.jsx(track.Track, {
    railEnd: adornmentEnd,
    railStart: adornmentStart,
    ...sliderStyleProps,
    children: /*#__PURE__*/jsxRuntime.jsxs(box.Box, {
      className: parts.container.className,
      onClick: isDisabled ? undefined : handlers.handleClick,
      onKeyDown: e => {
        var _handlers$handleKeyDo;
        if (isDisabled || e.key === 'Tab') {
          return;
        }
        (_handlers$handleKeyDo = handlers.handleKeyDown) === null || _handlers$handleKeyDo === void 0 || _handlers$handleKeyDo.call(handlers, e);
      },
      onPointerDown: isDisabled ? undefined : handlers.handlePointerDown,
      ref: sliderRef,
      role: "presentation",
      style: parts.container.style,
      children: [/*#__PURE__*/jsxRuntime.jsx(box.Box, {
        ...parts.baseArea
      }), /*#__PURE__*/jsxRuntime.jsx("input", {
        name: "sliderValue",
        ref: forwardedRef,
        type: "hidden",
        value: value
      }), /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        className: parts.filledArea.className,
        style: {
          ...parts.filledArea.style,
          width: `${widthPercentage}%`
        }
      }), /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        className: parts.thumb.className,
        ref: thumbRef,
        style: {
          ...parts.thumb.style,
          left: `${widthPercentage}%`,
          transition: isDragging ? 'none' : 'transform 0.05s ease-out'
        },
        ...a11yProps,
        ...consumerProps
      })]
    })
  });
});

exports.Slider = Slider;
