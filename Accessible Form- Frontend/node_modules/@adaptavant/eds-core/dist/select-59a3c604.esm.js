'use client';
import { mergeRefs } from '@react-aria/utils';
import { forwardRef, useCallback, Fragment } from 'react';
import { D as DropdownDownIcon } from './dropdown-down-icon-372942b0.esm.js';
import { t as tw } from './tw-c6a9a210.esm.js';
import { t as typography } from './styles-267c9284.esm.js';
import { i as inputHeightStylesLookup, b as inputPaddingStylesLookup } from './styles-12c293a4.esm.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { B as Box } from './box-a5dda214.esm.js';
import { useFieldContext, useInputA11yProps } from './context-2a1498a6.esm.js';
import { useCombinedFocusContainerInputStyles, FocusContainer } from './focus-container-9b45fd51.esm.js';
import './styles-53001919.esm.js';
import './index-dd10a77e.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';

/**
 * @note
 *
 * The `padding-inline-end` value for the root element should be calculated as:
 * The `width` of the icon plus twice the value of the iconWrapper's `padding-inline`
 * (as `padding-inline` is a shorthand for `padding-inline-start` and `padding-inline-end`).
 *
 * This is because the iconWrapper is absolutely positioned over the root
 * element and we do not want the text to overlap with the icon.
 */
const getSelectStyles = ({
  isDisabled,
  size
}) => ({
  root: tw`
		${inputHeightStylesLookup[size]}
		${inputPaddingStylesLookup['start']['withoutAdornment'][size]}
		${typography[size]}
		appearance-none
		aria-disabled:text-disabled
		bg-none
		flex
		pe-12
		text-primary
		w-full
	`,
  iconWrapper: tw`
		${inputPaddingStylesLookup['end']['withAdornment'][size]}
		${inputPaddingStylesLookup['start']['withAdornment'][size]}
		absolute
		end-0
		h-full
		inline-flex
		inset-y-0
		items-center
		justify-center
		pointer-events-none
	`,
  icon: tw`
		${iconSizeLookup[size]}
		${isDisabled ? 'text-disabled' : 'text-secondary'}
	`
});
const iconSizeLookup = {
  standard: 'h-4 w-4',
  large: 'h-6 w-6'
};

/**
 * Select
 *
 * @description
 * A dropdown select component that allows the user to select a single option
 * from a list.
 */
const Select = /*#__PURE__*/forwardRef(function Select({
  className = '',
  classNames = {},
  defaultValue,
  options: optionsOrGroups,
  placeholder,
  style = {},
  styles = {},
  value,
  ...consumerProps
}, forwardedRef) {
  const {
    isDisabled,
    isInvalid,
    isRequired,
    size
  } = useFieldContext();
  const a11yProps = useInputA11yProps({
    isDisabled,
    isInvalid,
    isRequired
  });
  const styleProps = useCombinedFocusContainerInputStyles({
    className,
    classNames,
    isDisabled,
    isInvalid,
    style,
    styles,
    tw: getSelectStyles({
      isDisabled,
      isInvalid,
      size
    })
  });
  const handleKeyDown = useCallback(event => {
    if (isDisabled && event.key !== 'Tab') {
      event.preventDefault();
    }
  }, [isDisabled]);
  const mapOptions = useCallback(opt =>
  /*#__PURE__*/
  /**
   * Because we use aria-disabled, screen readers can still access the dropdown.
   * Disabling the options as well reinforces that they are unselectable.
   */
  jsx("option", {
    disabled: isDisabled || opt.isDisabled,
    value: opt.value,
    children: opt.label
  }, opt.value), [isDisabled]);
  return /*#__PURE__*/jsx(FocusContainer, {
    classNames: {
      focusIndicator: {
        ...styleProps('focusIndicator')
      }.className
    },
    isDisabled: isDisabled,
    isInvalid: isInvalid,
    styles: {
      focusIndicator: {
        ...styleProps('focusIndicator').style
      }
    },
    children: ({
      ref
    }) => /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsxs(Box, {
        ...a11yProps,
        ...consumerProps,
        as: "select",
        defaultValue: defaultValue ?? placeholder ? '' : undefined,
        onKeyDown: handleKeyDown,
        ref: mergeRefs(ref, forwardedRef),
        value: value,
        ...styleProps('root'),
        children: [!value || placeholder ? /*#__PURE__*/jsx("option", {
          disabled: true,
          value: "",
          children: placeholder
        }) : null, optionsOrGroups.map(optionOrGroup => {
          if ('options' in optionOrGroup) {
            return /*#__PURE__*/jsx("optgroup", {
              disabled: optionOrGroup.isDisabled,
              label: optionOrGroup.label,
              children: optionOrGroup.options.map(mapOptions)
            }, optionOrGroup.label);
          }
          return mapOptions(optionOrGroup);
        })]
      }), /*#__PURE__*/jsx(Box, {
        as: "span",
        ...styleProps('iconWrapper'),
        children: /*#__PURE__*/jsx(DropdownDownIcon, {
          ...styleProps('icon')
        })
      })]
    })
  });
});
Select.displayName = 'Select';

export { Select };
