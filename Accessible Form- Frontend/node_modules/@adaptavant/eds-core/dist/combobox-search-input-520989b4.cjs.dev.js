'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var emery = require('emery');
var React = require('react');
var context$1 = require('./context-1e651be3.cjs.dev.js');
var utils$1 = require('./utils-1d447d37.cjs.dev.js');
var mergeProps = require('./merge-props-74bd38ff.cjs.dev.js');
var context = require('./context-1d59120d.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-88b49271.cjs.dev.js');
var search_input = require('./search-input-6e0fd191.cjs.dev.js');
var context$2 = require('./context-fb7f9049.cjs.dev.js');
require('./cx-26784cbb.cjs.dev.js');
require('clsx');
require('./merge-ids-b19ec20e.cjs.dev.js');
require('./index-3bdbdb42.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');

const ComboboxSearchInput = /*#__PURE__*/React.forwardRef(function ComboboxSearchInput(props, forwardedRef) {
  const {
    inputProps
  } = useComboboxSearchInput(props);
  const {
    onClear,
    onSelectionChange
  } = context.useCombobox();
  const {
    clearSelectedItem
  } = context$1.useDropdownContext();
  const handleOnClear = React.useCallback(() => {
    if (typeof onClear === 'function') {
      onClear();
    }
    clearSelectedItem();
    onSelectionChange(undefined);
  }, [clearSelectedItem, onClear, onSelectionChange]);
  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(search_input.SearchInput, {
      ...inputProps,
      onClear: handleOnClear,
      ref: forwardedRef
    }), /*#__PURE__*/jsxRuntime.jsx(LiveRegion, {})]
  });
});
ComboboxSearchInput.displayName = 'ComboboxSearchInput';
function useComboboxSearchInput(props) {
  const {
    inputValue = '',
    // Set inputValue to an empty string to prevent uncontrolled to controlled input warning. More info: https://reactjs.org/link/uncontrolled-to-controlled
    menuTrigger,
    onInputChange,
    onSelectionChange
  } = context.useCombobox();
  const {
    activeDescendantId,
    isMenuOpen,
    listId,
    popover,
    openMenu,
    clearSelectedItem
  } = context$1.useDropdownContext();
  const {
    isDisabled
  } = context$2.useFieldContext();
  const handleChange = React.useCallback(event => {
    if (!isMenuOpen) openMenu();
    if (onInputChange) onInputChange(event.target.value);
    if (event.target.value === '') {
      clearSelectedItem();
      if (onSelectionChange) {
        onSelectionChange(undefined);
      }
    }
  }, [clearSelectedItem, isMenuOpen, onInputChange, onSelectionChange, openMenu]);
  const handleFocus = React.useCallback(() => {
    if (menuTrigger === 'focus') openMenu();
  }, [menuTrigger, openMenu]);
  const referenceProps = popover.getReferenceProps();
  const handleKeyDown = useKeydownNavigation();
  const isAppleDevice = utils.isAppleDevice();
  const a11yProps = React.useMemo(() => ({
    'aria-activedescendant': isAppleDevice ? undefined : activeDescendantId,
    'aria-autocomplete': 'list',
    'aria-controls': listId,
    'aria-expanded': isMenuOpen,
    'aria-haspopup': 'listbox',
    autoComplete: 'off',
    autoCorrect: 'off',
    spellCheck: 'false',
    role: 'combobox'
  }), [activeDescendantId, isAppleDevice, isMenuOpen, listId]);
  const comboboxProps = React.useMemo(() => ({
    onKeyDown: isDisabled ? undefined : handleKeyDown,
    onChange: handleChange,
    onFocus: isDisabled ? undefined : handleFocus,
    value: inputValue
  }), [isDisabled, handleKeyDown, handleChange, handleFocus, inputValue]);
  return {
    inputProps: React.useMemo(() => ({
      ...mergeProps.mergeProps(props, a11yProps, comboboxProps),
      focusContainerRef: referenceProps.ref
    }), [props, a11yProps, comboboxProps, referenceProps.ref])
  };
}

/**
 * On desktop Safari with VoiceOver, the aria-activedescendant
 * attribute seems to be ignored so we have set up a aria-live region
 * to fake it.
 * However, older versions of VoiceOver of Safari for iOS it ignores
 * the aria-live region and only announces the aria-activedescendant
 * so we need to use both.
 */
function LiveRegion() {
  const isAppleDevice = utils.isAppleDevice();
  const {
    activeDescendantId,
    activeDescendantIndex,
    descendantCount,
    descendantNodes,
    selectedOptionId
  } = context$1.useDropdownContext();
  const [activeDescendantText, setActiveDescendantText] = React.useState(null);
  React.useEffect(() => {
    // get the text content of the active descendant
    if (activeDescendantIndex === -1 || !utils$1.isNodeListOfHTMLElements(descendantNodes)) {
      return undefined;
    }
    const activeDescendant = descendantNodes[activeDescendantIndex];
    if (activeDescendant && activeDescendant.textContent) {
      setActiveDescendantText(activeDescendant.textContent
      // Remove whitespace and zero-width space characters
      .replace(/[\s\u200B]+/g, ' ').trim());
    }
  }, [activeDescendantIndex, descendantNodes]);
  if (!isAppleDevice || descendantCount <= 0 || activeDescendantIndex > descendantCount) {
    return null;
  }
  const isSelected = activeDescendantId === selectedOptionId;
  const selectionStatus = isSelected ? 'Selected' : '';
  const positionInfo = `${activeDescendantIndex + 1} of ${descendantCount}`;
  const liveRegionText = activeDescendantText ? [activeDescendantText, selectionStatus, positionInfo].filter(Boolean).join('. ') : null;
  return /*#__PURE__*/jsxRuntime.jsx(box.Box, {
    "aria-live": "assertive",
    className: "sr-only",
    children: liveRegionText
  });
}
const supportedKeys = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'Escape', 'Enter', 'Tab'];
function isSupportedKey(key) {
  return supportedKeys.includes(key);
}
function useKeydownNavigation(onEnterInputHandler) {
  const {
    clickSelectedItem,
    closeMenu,
    descendantNodes,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem,
    isMenuOpen,
    openMenu
  } = context$1.useDropdownContext();

  // We need a useEffect to focus the first or last item after the menu opens
  // because we need to wait for the descendantNodes to be created and set (see usePopulateDescendantNodes).
  const [focusItemAfterOpen, setFocusItemAfterOpen] = React.useState();
  React.useEffect(() => {
    if (!isMenuOpen || !descendantNodes || !focusItemAfterOpen) return;
    if (focusItemAfterOpen === 'first') {
      goToFirstMenuItem();
    }
    if (focusItemAfterOpen === 'last') {
      goToLastMenuItem();
    }
    setFocusItemAfterOpen(undefined);
  }, [isMenuOpen, descendantNodes, focusItemAfterOpen, goToFirstMenuItem, goToLastMenuItem]);
  return React.useCallback(event => {
    // If we don't have a case for the key, we can return early.
    if (!isSupportedKey(event.code)) return;
    switch (event.code) {
      case 'ArrowUp':
        {
          event.preventDefault();
          if (isMenuOpen) {
            goToPreviousMenuItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('last');
          }
          return;
        }
      case 'ArrowDown':
        {
          event.preventDefault();
          if (isMenuOpen) {
            goToNextMenuItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('first');
          }
          return;
        }
      case 'Home':
        {
          event.preventDefault();
          goToFirstMenuItem();
          return;
        }
      case 'End':
        {
          event.preventDefault();
          goToLastMenuItem();
          return;
        }
      case 'Escape':
        {
          closeMenu();
          return;
        }
      case 'Enter':
        {
          event.preventDefault();
          if (isMenuOpen) {
            clickSelectedItem();
          } else {
            openMenu();
            setFocusItemAfterOpen('first');
          }
          if (onEnterInputHandler && typeof onEnterInputHandler === 'function') {
            onEnterInputHandler();
          }
          return;
        }
      case 'Tab':
        {
          closeMenu();
          return;
        }
      default:
        emery.assertNever(event.code);
    }
  }, [clickSelectedItem, closeMenu, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem, isMenuOpen, onEnterInputHandler, openMenu]);
}

exports.ComboboxSearchInput = ComboboxSearchInput;
exports.LiveRegion = LiveRegion;
exports.useComboboxSearchInput = useComboboxSearchInput;
exports.useKeydownNavigation = useKeydownNavigation;
