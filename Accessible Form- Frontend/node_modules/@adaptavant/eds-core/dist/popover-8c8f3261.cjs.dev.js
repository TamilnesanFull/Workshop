'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactDom = require('@floating-ui/react-dom');
var React = require('react');
var index = require('./index-3bdbdb42.cjs.dev.js');
var tw = require('./tw-cabb7e4c.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-88b49271.cjs.dev.js');
var create_portal = require('./create-portal-ca12b5da.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');

const getPopoverStyles = () => ({
  root: tw.tw`
			[outline:none]
			absolute
			bg-neutral
			border
			border-secondary
			flex
			flex-col
			high-contrast:border-solid
			overflow-hidden
			p-1
			rounded-12px
			shadow-20
			w-full
			z-10
		`
});

// ---------------------------------- Popover ----------------------------------

/**
 * Popover
 *
 * @description
 * The popover component provides the visual styles for popovers.
 * It should be used in conjunction with the `usePopover` hook which handles the
 * positioning logic.
 */

const Popover = /*#__PURE__*/React.forwardRef(function Popover({
  as = 'div',
  className = '',
  classNames = {},
  shouldUsePortal = false,
  style = {},
  styles = {},
  ...consumerProps
}, forwardedRef) {
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getPopoverStyles()
  });
  const createPortal = create_portal.useCreatePortal();
  const popover = /*#__PURE__*/jsxRuntime.jsx(box.Box, {
    ...consumerProps,
    as: as,
    ref: forwardedRef,
    ...styleProps('root')
  });
  return shouldUsePortal ? createPortal(popover) : popover;
});
Popover.displayName = 'Popover';

// -------------------------------- usePopover ---------------------------------

/**
 * usePopover
 *
 * @description
 * The `usePopover` hook handles the positioning logic for popovers.
 */
function usePopover({
  isOpen,
  isPopoverAlwaysMounted = false,
  matchReferenceWidth,
  maxHeight: maxHeightOption,
  maxWidth,
  offset: offsetProp = 4,
  placement = 'bottom-start',
  strategy = 'absolute'
} = {}) {
  const floating = reactDom.useFloating({
    placement,
    strategy,
    middleware: [
    /**
     * Adds distance between the reference and floating element
     * @see https://floating-ui.com/docs/offset
     */
    reactDom.offset(offsetProp),
    /**
     * Changes the placement of the floating element in order to keep it in view
     * @see https://floating-ui.com/docs/flip
     */
    reactDom.flip({
      fallbackStrategy: 'initialPlacement'
    }),
    /**
     * Allows you to change the size of the floating element
     * @see https://floating-ui.com/docs/size
     */
    reactDom.size({
      padding: offsetProp,
      // Prevents the floating element from hitting the edge of the screen
      apply({
        availableWidth,
        availableHeight,
        elements,
        rects
      }) {
        // Popovers can have a predefined max-height if there is enough room on the screen
        const maxHeight = maxHeightOption && availableHeight > maxHeightOption ? maxHeightOption : availableHeight;
        Object.assign(elements.floating.style, {
          maxHeight: getConstrainedSize({
            availableSize: availableHeight,
            maxSize: maxHeight
          }),
          /**
           * @see https://floating-ui.com/docs/size#match-reference-width
           */
          ...(matchReferenceWidth ? {
            width: `${rects.reference.width}px`
          } : {
            maxWidth: getConstrainedSize({
              availableSize: availableWidth,
              maxSize: maxWidth
            })
          })
        });
      }
    })],
    /**
     * Ensures the floating element remains anchored to its reference element
     * @see https://floating-ui.com/docs/react#anchoring
     */
    ...(!isPopoverAlwaysMounted && {
      whileElementsMounted(referenceEl, floatingEl, update) {
        const cleanup = reactDom.autoUpdate(referenceEl, floatingEl, update, {
          ancestorScroll: false,
          /**
           * JSDOM does not support ResizeObserver
           * @see https://floating-ui.com/docs/autoupdate#elementresize
           */
          elementResize: typeof ResizeObserver === 'function'
        });
        return cleanup;
      }
    })
  });

  /**
   * Ensures the floating element remains anchored to its reference element when
   * using `display: none` or `visibility: hidden`
   *
   * @see https://floating-ui.com/docs/react#anchoring
   */
  React.useEffect(() => {
    if (!isOpen || !isPopoverAlwaysMounted) return;
    if (!floating.elements.floating || !floating.elements.reference) return;
    const cleanup = reactDom.autoUpdate(floating.elements.reference, floating.elements.floating, floating.update, {
      ancestorScroll: false,
      /**
       * JSDOM does not support ResizeObserver
       * @see https://floating-ui.com/docs/autoupdate#elementresize
       */
      elementResize: typeof ResizeObserver === 'function'
    });
    return cleanup;
  }, [floating.elements.floating, floating.elements.reference, floating.update, isOpen, isPopoverAlwaysMounted]);
  function getReferenceProps() {
    return {
      ref: floating.refs.setReference
    };
  }
  function getPopoverProps() {
    return {
      ref: floating.refs.setFloating,
      style: floating.floatingStyles
    };
  }
  return {
    getReferenceProps,
    getPopoverProps,
    referenceRef: floating.refs.reference,
    popoverRef: floating.refs.floating
  };
}
function getConstrainedSize({
  availableSize,
  maxSize
}) {
  if (typeof maxSize === 'number') {
    const size = maxSize ? Math.min(availableSize, maxSize) : availableSize;
    return `${size}px`;
  }
  return maxSize;
}

exports.Popover = Popover;
exports.usePopover = usePopover;
