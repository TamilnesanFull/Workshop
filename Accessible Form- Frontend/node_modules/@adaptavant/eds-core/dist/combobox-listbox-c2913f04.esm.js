'use client';
import { useRef, useEffect, Fragment, useMemo } from 'react';
import { useDropdownContext } from './context-6e374e37.esm.js';
import { g as getStyleProps } from './index-dd10a77e.esm.js';
import { v as visuallyHiddenStyles } from './visually-hidden-60af4b9e.esm.js';
import { a as forwardRefWithGenericComponent } from './forward-ref-a0e1d5d1.esm.js';
import { m as mergeProps } from './merge-props-5c13cba9.esm.js';
import { a as getComboboxListboxStyles } from './styles-435dd498.esm.js';
import { jsxs, jsx } from 'react/jsx-runtime';
import { Listbox } from './listbox-279326e9.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';
import '@react-aria/utils';
import './cx-c5d68be6.esm.js';
import 'clsx';
import './merge-ids-c2d2d3d7.esm.js';
import './tw-c6a9a210.esm.js';

const ComboboxListbox = forwardRefWithGenericComponent(function ComboboxListbox(props, forwardedRef) {
  const {
    listboxProps,
    noResultsFallback
  } = useComboboxListbox(props, forwardedRef);
  const {
    descendantNodes,
    dispatch,
    isMenuOpen
  } = useDropdownContext();

  // Ref to track if the component has already been initialized
  const isFirstRenderRef = useRef(true);

  /**
   * Sets the active descendant in the dropdown when the menu is open.
   * Finds the selected option within the popover and dispatches an action
   * to update the context with the index and ID of the active option.
   */
  useEffect(() => {
    if (!isMenuOpen || !descendantNodes || !isFirstRenderRef.current) {
      return;
    }
    const options = Array.from(descendantNodes);
    const activeOption = options.find(option => option.getAttribute('aria-selected') === 'true');
    if (activeOption) {
      dispatch({
        type: 'SET_ACTIVE_DESCENDANT_INDEX',
        payload: {
          activeIndex: options.indexOf(activeOption),
          activeId: activeOption.id
        }
      });
    }
    isFirstRenderRef.current = false;
  }, [descendantNodes, dispatch, isMenuOpen]);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(Listbox, {
      ...listboxProps
    }), noResultsFallback]
  });
});
function useComboboxListbox({
  children,
  className = '',
  classNames = {},
  noResultsFallback,
  options,
  style = {},
  styles = {},
  ...consumerProps
}, forwardedRef) {
  const {
    activeDescendantId,
    comboboxId,
    isMenuOpen,
    listId
  } = useDropdownContext();
  const isEmptyOptions = useMemo(() => Boolean(options && options.length === 0), [options]);
  const styleProps = useMemo(() => getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getComboboxListboxStyles()
  }), [className, classNames, style, styles]);
  return {
    listboxProps: useMemo(() => mergeProps(consumerProps, {
      'aria-activedescendant': activeDescendantId,
      'aria-labelledby': comboboxId,
      children: isMenuOpen ? children : null,
      id: listId,
      options: options,
      ref: forwardedRef
    }, styleProps('root', isEmptyOptions ? visuallyHiddenStyles : undefined)), [activeDescendantId, children, comboboxId, consumerProps, forwardedRef, isEmptyOptions, isMenuOpen, listId, options, styleProps]),
    noResultsFallback: useMemo(() => isMenuOpen && isEmptyOptions ? noResultsFallback : null, [isMenuOpen, isEmptyOptions, noResultsFallback])
  };
}

export { ComboboxListbox, useComboboxListbox };
