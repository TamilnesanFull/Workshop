'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var button = require('./button-4b229f71.cjs.dev.js');
var removeIcon = require('./remove-icon-ad27b88f.cjs.dev.js');
var searchIcon = require('./search-icon-90d6c5d5.cjs.dev.js');
var index = require('./index-3bdbdb42.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var context = require('./context-fb7f9049.cjs.dev.js');
var clickable_adornment = require('./clickable-adornment-0aeaece2.cjs.dev.js');
var text_input = require('./text-input-ace7389d.cjs.dev.js');
require('./styles-32c512c4.cjs.dev.js');
require('./tw-cabb7e4c.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');

const getSearchInputStyles = ({
  size,
  isDisabled
}) => ({
  root: `
		flex
		flex-nowrap
		flex-row
	`,
  adornmentStart: `
	    leading-none
		${adornmentStartOffsetLookup[size]}
		${isDisabled ? 'cursor-default text-disabled' : 'text-primary'}
	`,
  adornmentEnd: `
	    leading-none
		${adornmentEndOffsetLookup[size]}
		${isDisabled ? 'cursor-default text-disabled' : 'text-primary'}
	`
});
const adornmentStartOffsetLookup = {
  standard: 'ps-2',
  large: 'ps-3'
};
const adornmentEndOffsetLookup = {
  standard: 'pe-2',
  large: 'pe-3'
};

/**
 * SearchInput
 *
 * @description
 * A customizable input field for search functionality.
 * It includes features like clearing the input and handling escape key presses.
 */
const SearchInput = /*#__PURE__*/React.forwardRef(function SearchInput({
  className = '',
  classNames = {},
  onBlur,
  onChange,
  onClear,
  onFocus,
  onKeyDown,
  style = {},
  styles = {},
  value,
  ...consumerProps
}, forwardedRef) {
  // Refs and state
  const {
    isDisabled
  } = context.useFieldContext();
  const internalRef = React.useRef(null);
  const [inputValue, setInputValue] = React.useState(value);

  // Determine if the input is controlled or not
  const isControlled = value !== undefined;
  const clearInput = React.useCallback(() => {
    setInputValue('');
    if (onClear) onClear();
  }, [onClear]);
  const handleKeyDown = React.useCallback(event => {
    // Clears the input when the escape key is pressed and input is not "disabled"
    if (!isDisabled && event.key === 'Escape') {
      clearInput();
    }
    if (onKeyDown) onKeyDown(event);
  }, [clearInput, isDisabled, onKeyDown]);

  // Event handlers
  function handleChange(event) {
    // Update internal state
    setInputValue(event.target.value);

    // Call onChange callback if provided
    if (onChange) onChange(event);
  }
  function handleBlur(event) {
    if (onBlur) onBlur(event);
  }
  function handleFocus(event) {
    if (onFocus) onFocus(event);
  }

  // Set state during render to avoid using an effect
  if (isControlled && value !== inputValue) {
    setInputValue(value);
  }

  // Styling
  const {
    size
  } = context.useFieldContext();
  const styleProps = index.getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getSearchInputStyles({
      size,
      isDisabled
    })
  });
  const searchAdornment = /*#__PURE__*/jsxRuntime.jsx(clickable_adornment.ClickableAdornment, {
    ...styleProps('adornmentStart'),
    children: /*#__PURE__*/jsxRuntime.jsx(searchIcon.SearchIcon, {
      size: button.buttonSizeToIconSize[size]
    })
  });
  const shouldRenderClearAdornment = React.useMemo(() => {
    // Check if inputValue is not empty
    if (Boolean(inputValue)) {
      return isControlled ?
      // For controlled inputs, additionally check if onClear is provided
      Boolean(onClear) :
      // For uncontrolled inputs, always render the clear adornment
      true;
    }
    // If inputValue is empty, don't render the clear adornment
    return false;
  }, [inputValue, isControlled, onClear]);
  const clearAdornment = shouldRenderClearAdornment ? /*#__PURE__*/jsxRuntime.jsx(clickable_adornment.ClickableAdornment, {
    ...styleProps('adornmentEnd'),
    onClick: isDisabled ? undefined : clearInput,
    children: /*#__PURE__*/jsxRuntime.jsx(removeIcon.RemoveIcon, {
      size: button.buttonSizeToIconSize[size]
    })
  }) : null;
  return /*#__PURE__*/jsxRuntime.jsx(text_input.TextInput, {
    ...consumerProps,
    adornmentEnd: clearAdornment,
    adornmentStart: searchAdornment,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    ref: utils.mergeRefs(internalRef, forwardedRef),
    value: inputValue,
    ...styleProps('root')
  });
});
SearchInput.displayName = 'SearchInput';

exports.SearchInput = SearchInput;
