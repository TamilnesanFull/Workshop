'use client';
import { useState, useCallback, useEffect, useRef, Fragment } from 'react';
import { g as getStyleProps } from './index-dd10a77e.esm.js';
import { v as visuallyHiddenStyles } from './visually-hidden-60af4b9e.esm.js';
import { useProvidedOrGeneratedId } from './use-provided-or-generated-id-70d42050.esm.js';
import { t as tw } from './tw-c6a9a210.esm.js';
import { jsx, jsxs } from 'react/jsx-runtime';
import { m as mergeProps } from './merge-props-5c13cba9.esm.js';
import { useTooltip } from './tooltip-342f030f.esm.js';
import { usePopover, Popover } from './popover-55e45b10.esm.js';
import './tw-merge-91a8b6ee.esm.js';
import 'tailwind-merge';
import '../tokens/dist/adaptavant-eds-core-tokens.esm.js';
import '@react-aria/utils';
import './cx-c5d68be6.esm.js';
import 'clsx';
import './merge-ids-c2d2d3d7.esm.js';

const getTooltipStyles = () => ({
  root: tw`
			bg-inverse
			border-none
			overflow-y-auto
			px-2
			py-0.5
			rounded-4px
			text-body-12
			text-inverse-secondary
			w-max
		`
});

const TOOLTIP_TIMEOUT_MS = 500;

/**
 * Tooltip
 *
 * @description
 * A popup that displays information related to an element when the element
 * receives keyboard focus or the mouse hovers over it.
 */
function Tooltip({
  children,
  className = '',
  classNames = {},
  content,
  id: idProp,
  maxWidth = 200,
  placement = 'top',
  shouldUsePortal = true,
  strategy = 'absolute',
  style = {},
  styles = {},
  visibilityHidden = false,
  ...consumerProps
}) {
  const styleProps = getStyleProps({
    className,
    classNames,
    style,
    styles,
    tw: getTooltipStyles()
  });
  const context = useTooltip();
  const tooltipId = useProvidedOrGeneratedId(idProp);
  const isVisible = context.visibleTooltipId === tooltipId;
  const [hideTimeoutId, setHideTimeoutId] = useState();
  const [isTouchEvent, setIsTouchEvent] = useState(false);
  let prevActiveElement = undefined;
  const clearHideTimeout = useCallback(() => {
    //	The check on `context.visibleTooltipId` ensures that the correct tooltip is hidden,
    //   especially when the user hovers over multiple tooltip trigger elements in quick succession.
    //   This solution works best when there is a gap between the tooltip trigger elements.
    //   If no gap exists between them, the issue may still occur.
    if (hideTimeoutId && context.visibleTooltipId) {
      clearTimeout(hideTimeoutId);
      //	The state update for `hideTimeoutId` verifies if the timeout is still valid
      //   (i.e., it checks the previous value of `hideTimeoutId`). This is important in cases
      //   where the tooltip doesn't hide as expected after the cursor leaves the trigger element.
      //   If the previous timeout is the same as the current one, it clears the timeout from the queue
      //   and sets `hideTimeoutId` to `undefined` to prevent lingering tooltips.
      setHideTimeoutId(prevTimeoutId => {
        return prevTimeoutId === hideTimeoutId ? undefined : prevTimeoutId;
      });
      setIsTouchEvent(false);
    }
  }, [context.visibleTooltipId, hideTimeoutId]);
  function showTooltip() {
    if (isTouchEvent) return;
    clearHideTimeout();
    context.showTooltip(tooltipId);
  }
  function startHideTooltip() {
    const timeoutId = window.setTimeout(() => {
      context.hideTooltip(tooltipId);
    }, TOOLTIP_TIMEOUT_MS);
    setHideTimeoutId(timeoutId);
  }
  function hideTooltipImmediately() {
    context.hideTooltip(tooltipId);
  }
  function touchEventHandler() {
    setIsTouchEvent(true);
    clearHideTimeout();
    context.showTooltip(tooltipId);
    startHideTooltip();
  }

  // Cleanup hideTimeoutId when component unmounts or before re-running the effect
  useEffect(() => {
    return clearHideTimeout;
  }, [clearHideTimeout]);

  // Effect for handling the Escape key press
  useEffect(() => {
    function handleEscape(event) {
      if (event.key === 'Escape') {
        context.hideTooltip(tooltipId);
      }
    }
    if (isVisible) {
      document.addEventListener('keydown', handleEscape);
      return () => {
        document.removeEventListener('keydown', handleEscape);
      };
    }
  }, [context, isVisible, tooltipId]);
  const initialContentRef = useRef(content);
  const isInitialContent = content === initialContentRef.current;

  // prop getters for the popover element (the tooltip)
  // and the reference element (the trigger)
  const {
    getPopoverProps,
    getReferenceProps
  } = usePopover({
    maxWidth,
    placement,
    isOpen: isVisible,
    isPopoverAlwaysMounted: true,
    strategy
  });

  // props for the trigger element that the tooltip is anchored to
  const triggerProps = {
    ...getReferenceProps(),
    'aria-describedby': visibilityHidden ? undefined : tooltipId,
    /**
     * On blur, store the current active element in `prevActiveElement`
     * to track which element was previously focused.
     */
    onBlur: visibilityHidden ? undefined : () => {
      prevActiveElement = document.activeElement;
      hideTooltipImmediately();
    },
    /**
     * On focus, check if the current active element is the same as `prevActiveElement`.
     * If they match, this means the focus event was likely triggered by a tab switch,
     * so we prevent the tooltip from showing. Otherwise, show the tooltip.
     */
    onFocus: visibilityHidden ? undefined : () => {
      if (document.activeElement === prevActiveElement) {
        return;
      }
      showTooltip();
    },
    onMouseEnter: visibilityHidden ? undefined : showTooltip,
    onMouseLeave: visibilityHidden ? undefined : startHideTooltip,
    // event to trigger hidetooltip on mobile touch
    onTouchEnd: visibilityHidden ? undefined : touchEventHandler
  };

  // props for the tooltip element
  const tooltipProps = mergeProps(consumerProps, {
    id: tooltipId,
    onMouseEnter: showTooltip,
    onMouseLeave: startHideTooltip,
    onTouchEnd: startHideTooltip,
    role: 'tooltip'
  }, isVisible ? getPopoverProps() : {}, isVisible ? styleProps('root') : {
    style: visuallyHiddenStyles
  });

  // pass children the triggerProps so that the consumer can apply them
  // to the own trigger elements.

  const trigger = children({
    triggerProps
  });

  // Trigger an alert announcement when content changes.
  // This is necessary because screen readers don't announce changes
  // in the content of the element referenced by `aria-describedby`.
  // If the content remains unchanged (initial content),
  // suppress the announcement by setting `aria-hidden` to true,
  // as this is not new information.
  const alert = /*#__PURE__*/jsx("div", {
    "aria-hidden": isInitialContent,
    className: "sr-only",
    role: "alert",
    children: content
  });
  return visibilityHidden ? /*#__PURE__*/jsx(Fragment, {
    children: trigger
  }) : /*#__PURE__*/jsxs(Fragment, {
    children: [trigger, /*#__PURE__*/jsxs(Popover, {
      ...tooltipProps,
      shouldUsePortal: shouldUsePortal,
      children: [content, alert]
    })]
  });
}
Tooltip.displayName = 'Tooltip';

export { Tooltip };
