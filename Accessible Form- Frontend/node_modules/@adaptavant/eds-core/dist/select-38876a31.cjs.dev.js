'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var React = require('react');
var dropdownDownIcon = require('./dropdown-down-icon-e861b656.cjs.dev.js');
var tw = require('./tw-cabb7e4c.cjs.dev.js');
var styles$1 = require('./styles-3e350289.cjs.dev.js');
var styles = require('./styles-b5db22e5.cjs.dev.js');
var jsxRuntime = require('react/jsx-runtime');
var box = require('./box-88b49271.cjs.dev.js');
var context = require('./context-fb7f9049.cjs.dev.js');
var focus_container = require('./focus-container-f89af8ff.cjs.dev.js');
require('./styles-32c512c4.cjs.dev.js');
require('./index-3bdbdb42.cjs.dev.js');
require('./tw-merge-70bc959c.cjs.dev.js');
require('tailwind-merge');
require('../tokens/dist/adaptavant-eds-core-tokens.cjs.dev.js');

/**
 * @note
 *
 * The `padding-inline-end` value for the root element should be calculated as:
 * The `width` of the icon plus twice the value of the iconWrapper's `padding-inline`
 * (as `padding-inline` is a shorthand for `padding-inline-start` and `padding-inline-end`).
 *
 * This is because the iconWrapper is absolutely positioned over the root
 * element and we do not want the text to overlap with the icon.
 */
const getSelectStyles = ({
  isDisabled,
  size
}) => ({
  root: tw.tw`
		${styles.inputHeightStylesLookup[size]}
		${styles.inputPaddingStylesLookup['start']['withoutAdornment'][size]}
		${styles$1.typography[size]}
		appearance-none
		aria-disabled:text-disabled
		bg-none
		flex
		pe-12
		text-primary
		w-full
	`,
  iconWrapper: tw.tw`
		${styles.inputPaddingStylesLookup['end']['withAdornment'][size]}
		${styles.inputPaddingStylesLookup['start']['withAdornment'][size]}
		absolute
		end-0
		h-full
		inline-flex
		inset-y-0
		items-center
		justify-center
		pointer-events-none
	`,
  icon: tw.tw`
		${iconSizeLookup[size]}
		${isDisabled ? 'text-disabled' : 'text-secondary'}
	`
});
const iconSizeLookup = {
  standard: 'h-4 w-4',
  large: 'h-6 w-6'
};

/**
 * Select
 *
 * @description
 * A dropdown select component that allows the user to select a single option
 * from a list.
 */
const Select = /*#__PURE__*/React.forwardRef(function Select({
  className = '',
  classNames = {},
  defaultValue,
  options: optionsOrGroups,
  placeholder,
  style = {},
  styles = {},
  value,
  ...consumerProps
}, forwardedRef) {
  const {
    isDisabled,
    isInvalid,
    isRequired,
    size
  } = context.useFieldContext();
  const a11yProps = context.useInputA11yProps({
    isDisabled,
    isInvalid,
    isRequired
  });
  const styleProps = focus_container.useCombinedFocusContainerInputStyles({
    className,
    classNames,
    isDisabled,
    isInvalid,
    style,
    styles,
    tw: getSelectStyles({
      isDisabled,
      isInvalid,
      size
    })
  });
  const handleKeyDown = React.useCallback(event => {
    if (isDisabled && event.key !== 'Tab') {
      event.preventDefault();
    }
  }, [isDisabled]);
  const mapOptions = React.useCallback(opt =>
  /*#__PURE__*/
  /**
   * Because we use aria-disabled, screen readers can still access the dropdown.
   * Disabling the options as well reinforces that they are unselectable.
   */
  jsxRuntime.jsx("option", {
    disabled: isDisabled || opt.isDisabled,
    value: opt.value,
    children: opt.label
  }, opt.value), [isDisabled]);
  return /*#__PURE__*/jsxRuntime.jsx(focus_container.FocusContainer, {
    classNames: {
      focusIndicator: {
        ...styleProps('focusIndicator')
      }.className
    },
    isDisabled: isDisabled,
    isInvalid: isInvalid,
    styles: {
      focusIndicator: {
        ...styleProps('focusIndicator').style
      }
    },
    children: ({
      ref
    }) => /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsxs(box.Box, {
        ...a11yProps,
        ...consumerProps,
        as: "select",
        defaultValue: defaultValue ?? placeholder ? '' : undefined,
        onKeyDown: handleKeyDown,
        ref: utils.mergeRefs(ref, forwardedRef),
        value: value,
        ...styleProps('root'),
        children: [!value || placeholder ? /*#__PURE__*/jsxRuntime.jsx("option", {
          disabled: true,
          value: "",
          children: placeholder
        }) : null, optionsOrGroups.map(optionOrGroup => {
          if ('options' in optionOrGroup) {
            return /*#__PURE__*/jsxRuntime.jsx("optgroup", {
              disabled: optionOrGroup.isDisabled,
              label: optionOrGroup.label,
              children: optionOrGroup.options.map(mapOptions)
            }, optionOrGroup.label);
          }
          return mapOptions(optionOrGroup);
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(box.Box, {
        as: "span",
        ...styleProps('iconWrapper'),
        children: /*#__PURE__*/jsxRuntime.jsx(dropdownDownIcon.DropdownDownIcon, {
          ...styleProps('icon')
        })
      })]
    })
  });
});
Select.displayName = 'Select';

exports.Select = Select;
