'use strict';

/**
 * Retrieves the ID of the active descendant node from a list of descendant nodes.
 *
 * @param params - The input parameters for the function.
 * @param params.descendantNodes - A list of descendant nodes.
 * @param params.activeDescendantIndex - The index of the active descendant node.
 * @returns The ID of the active descendant node, or undefined if the index is out of bounds or nodes are not valid.
 */
function getActiveDescendantId({
  activeDescendantIndex,
  descendantNodes
}) {
  // Use the type guard function to ensure descendantNodes is valid
  if (!isNodeListOfHTMLElements(descendantNodes) || activeDescendantIndex < 0 || activeDescendantIndex >= descendantNodes.length) {
    return undefined;
  }
  const descendantNode = descendantNodes[activeDescendantIndex];
  return descendantNode ? descendantNode.id : undefined;
}

/**
 * Checks if a given value is a valid NodeListOf<HTMLElement>.
 * Type guard function.
 * @param nodes - The value to check.
 * @returns true if the value is a valid NodeListOf<HTMLElement>, false otherwise.
 */
function isNodeListOfHTMLElements(nodes) {
  if (nodes === undefined || typeof NodeList === 'undefined' || typeof HTMLElement === 'undefined') {
    return false;
  }
  if (!(nodes instanceof NodeList)) {
    return false;
  }
  if (!Array.from(nodes).every(node => node instanceof HTMLElement)) {
    return false;
  }
  return true;
}

/**
 * Calculates the bounding client rectangle of a child element relative to its parent element.
 *
 * @param {Element} child - The child element for which to calculate the bounding rectangle.
 * @param {Element} parent - The parent element to which the child's bounding rectangle is relative.
 * @returns {Object} An object containing the top and bottom properties, representing the child's
 * top and bottom positions relative to the parent element.
 */
function getRelativeBoundingClientRect(child, parent) {
  const childRect = child.getBoundingClientRect();
  const parentRect = parent.getBoundingClientRect();
  return {
    top: childRect.top - parentRect.top,
    bottom: childRect.bottom - parentRect.top
  };
}

/**
 * Checks if a descendant node is disabled.
 *
 * @param descendantNodes - The array of descendant nodes.
 * @param index - The index of the descendant node to check.
 * @returns "true" if the descendant node is disabled, "false" if it's not.
 */
function isDescendantNodeDisabled(descendantNodes, index) {
  if (!descendantNodes) return false;
  const descendant = descendantNodes[index];
  if (!descendant) return false;
  return (descendant === null || descendant === void 0 ? void 0 : descendant.getAttribute('aria-disabled')) === 'true';
}

/**
 * Finds the first non-disabled index in the descendant nodes.
 * @param descendantNodes - The array of descendant nodes.
 * @param descendantCount - The total number of descendant nodes.
 * @returns The index of the first non-disabled node, or -1 if all are disabled.
 */
function findFirstNonDisabledIndex(descendantNodes, descendantCount) {
  if (!descendantNodes || descendantCount <= 0) {
    return -1; // Early return to handle NAN case
  }
  let index = 0;

  // Find the first non-disabled descendant till we reach the end of the list
  while (index < descendantCount && isDescendantNodeDisabled(descendantNodes, index)) {
    index++;
  }
  return index < descendantCount ? index : -1; // Return -1 if all are disabled
}

/**
 * Finds the last non-disabled index in the descendant nodes.
 * @param descendantNodes - The array of descendant nodes.
 * @param descendantCount - The total number of descendant nodes.
 * @returns The index of the last non-disabled node, or -1 if all are disabled.
 */
function findLastNonDisabledIndex(descendantNodes, descendantCount) {
  if (!descendantNodes || descendantCount <= 0) {
    return -1; // Early return to handle NAN case
  }
  let index = descendantCount - 1;

  // Find the last non-disabled descendant till we reach the start of the list
  while (index >= 0 && isDescendantNodeDisabled(descendantNodes, index)) {
    index--;
  }
  return index >= 0 ? index : -1; // Return -1 if all are disabled
}

/**
 * Finds the next non-disabled index in the descendant nodes, starting from the active index.
 * @param descendantNodes - The array of descendant nodes.
 * @param activeIndex - The current active index.
 * @param descendantCount - The total number of descendant nodes.
 * @returns The index of the next non-disabled node, or -1 if all are disabled.
 */
function findNextNonDisabledIndex(descendantNodes, activeIndex, descendantCount) {
  if (!descendantNodes || descendantCount <= 0) {
    return -1; // Early return to handle NAN case
  }
  // Start from the next index or the first index if activeIndex is invalid
  let index = activeIndex;
  let loopCount = 0;

  // Loop to find the next non-disabled descendant
  do {
    index = (index + 1) % descendantCount; // Move to the next index, wrapping around
    if (!isDescendantNodeDisabled(descendantNodes, index)) {
      return index; // Early return if the next node is not disabled
    }
    loopCount++; // Increment the loop count
  } while (loopCount < descendantCount); // Stop when we've looped through all nodes
  return -1; // All descendants are disabled
}

/**
 * Finds the previous non-disabled index in the descendant nodes, starting from the active index.
 * @param descendantNodes - The array of descendant nodes.
 * @param activeIndex - The current active index.
 * @param descendantCount - The total number of descendant nodes.
 * @returns The index of the previous non-disabled node, or -1 if all are disabled.
 */
function findPreviousNonDisabledIndex(descendantNodes, activeIndex, descendantCount) {
  if (!descendantNodes || descendantCount <= 0) {
    return -1; // Early return to handle NAN case
  }
  // Start from the previous index or wrap to the last index if activeIndex is invalid
  let index = activeIndex - 1;
  let loopCount = 0;

  // Check if the current activeDescendantIndex is outside the range
  if (activeIndex >= descendantCount || index < 0) {
    index = descendantCount - 1; // Wrap to last index
  }

  // Loop to find the previous non-disabled descendant
  do {
    if (!isDescendantNodeDisabled(descendantNodes, index)) {
      return index; // Early return if the previous node is not disabled
    }
    index = (index - 1 + descendantCount) % descendantCount; // Move to the previous index, wrapping around
    loopCount++; // Increment the loop count
  } while (loopCount < descendantCount); // Stop when we've looped through all nodes
  return -1; // All descendants are disabled
}

/**
 * Finds the first matching index in the descendant nodes, starting from the current index.
 *
 * This function is used to move the active index when a user types a character, and it should
 * find the first node that matches the new search term. If no match is found, it returns -1.
 *
 * The search term is matched against the text content of each node, and the match is case-insensitive.
 *
 * @param descendantNodes - The array of descendant nodes.
 * @param descendantCount - The total number of descendant nodes.
 * @param currentIndex - The current active index.
 * @param offset - The offset from the current index to start the search.
 * @param newSearchTerm - The new search term to match.
 * @returns The index of the first matching node, or -1 if no match is found.
 */
function findMatchingIndex(descendantNodes, descendantCount, currentIndex, offset, newSearchTerm) {
  if (!descendantNodes || descendantCount <= 0) {
    return -1;
  }

  // Find the first matching item in a single loop with early exit
  let matchIndex = -1;
  for (let i = 0; i < descendantCount; i++) {
    // Calculate the index accounting for reordering
    const itemIndex = (currentIndex + offset + i) % descendantCount;
    const node = descendantNodes[itemIndex];

    // Skip for disabled nodes
    if ((node === null || node === void 0 ? void 0 : node.getAttribute('aria-disabled')) === 'true') {
      continue;
    }
    const itemText = ((node === null || node === void 0 ? void 0 : node.textContent) ?? '').replace(/[\s\u200B]+/g, ' ') // Replace multiple spaces or zero-width characters with a single space
    .trim().toLowerCase();

    // Check if the item starts with the new search term
    if (itemText !== null && itemText !== void 0 && itemText.startsWith(newSearchTerm)) {
      matchIndex = itemIndex; // Match found, store the index
      break; // Early exit, no need to continue
    }
  }
  return matchIndex;
}

/**
 * This function will return a new state object with the updated search term and the index of the active descendant.
 * It will also find the first matching item in the descendants that starts with the new search term.
 * If no match is found, it will return the current active descendant index.
 * If the descendantNodes is undefined or empty, it will early return with the new search term and the current active descendant index
 *
 * @param params.descendantNodes - A list of descendant nodes.
 * @param params.descendantCount - The total number of descendant nodes.
 * @param params.activeDescendantIndex - The current active descendant index.
 * @param params.lastKeyPressTime - The timestamp of the last key press.
 * @param params.currentTime - The current timestamp.
 * @param params.eventKey - The key that was pressed.
 * @param params.descendantSearchTerm - The current search term being built.
 * @returns return.newState.descendantSearchTerm - The updated search term.
 * @returns return.newState.lastKeyPressTime - The updated last key press time.
 * @returns return.newState.activeDescendantIndex - The updated active descendant index.
 */
function updateDescendantSearchTerm({
  descendantNodes,
  descendantCount,
  activeDescendantIndex,
  lastKeyPressTime,
  currentTime,
  eventKey,
  descendantSearchTerm
}) {
  // Calculate the time difference between the last key press and the current time
  const timeDiff = currentTime - lastKeyPressTime;

  // Determine if this was a quick key press to continue typing a search term
  const quickPress = timeDiff < 350;

  // Update the search term based on whether it's a continuation of the last search term
  const newSearchTerm = quickPress ? `${descendantSearchTerm}${eventKey.toLowerCase()}` : eventKey.toLowerCase();

  // Early return if descendantNodes is undefined or empty
  if (!descendantNodes || descendantCount === 0) {
    return {
      newState: {
        descendantSearchTerm: newSearchTerm,
        lastKeyPressTime: currentTime,
        activeDescendantIndex
      }
    };
  }

  // Get the index of the current active descendant
  const currentIndex = activeDescendantIndex >= 0 ? activeDescendantIndex : -1;

  // Define the offset based on whether the key press is quick or not
  const offset = quickPress ? 0 : 1;
  const matchingIndex = findMatchingIndex(descendantNodes, descendantCount, currentIndex, offset, newSearchTerm);
  return {
    newState: {
      descendantSearchTerm: newSearchTerm,
      lastKeyPressTime: currentTime,
      activeDescendantIndex: matchingIndex !== -1 ? matchingIndex // If a match is found, update the active descendant index
      : activeDescendantIndex // If no match is found, return the state without changes to the active descendant
    }
  };
}
const MOBILE_TOGGLE_POINT = 768;

exports.MOBILE_TOGGLE_POINT = MOBILE_TOGGLE_POINT;
exports.findFirstNonDisabledIndex = findFirstNonDisabledIndex;
exports.findLastNonDisabledIndex = findLastNonDisabledIndex;
exports.findNextNonDisabledIndex = findNextNonDisabledIndex;
exports.findPreviousNonDisabledIndex = findPreviousNonDisabledIndex;
exports.getActiveDescendantId = getActiveDescendantId;
exports.getRelativeBoundingClientRect = getRelativeBoundingClientRect;
exports.isNodeListOfHTMLElements = isNodeListOfHTMLElements;
exports.updateDescendantSearchTerm = updateDescendantSearchTerm;
