'use client';
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@react-aria/utils');
var emery = require('emery');
var React = require('react');
var context = require('./context-38cb595b.cjs.prod.js');
var mergeProps = require('./merge-props-60701ce8.cjs.prod.js');
var combobox_search_input = require('./combobox-search-input-090c1a94.cjs.prod.js');
var jsxRuntime = require('react/jsx-runtime');
var search_input = require('./search-input-69c46713.cjs.prod.js');
require('./cx-86353291.cjs.prod.js');
require('clsx');
require('./merge-ids-2d47bd24.cjs.prod.js');

const FilterMenuSearchInput = /*#__PURE__*/React.forwardRef(function FilterMenuSearchInput({
  onClear,
  ...consumerProps
}, forwardedRef) {
  /**
   * Uses useEffect to clear input when the popover closes.
   *
   * This component doesn't know when it will be unmounted, so we use
   * useEffect's cleanup function to clear the input upon unmounting.
   *
   * The ESLint rule (`react-hooks/exhaustive-deps`) is disabled to prevent
   * adding `onClear` to the dependency array. If `onClear` is defined inline
   * then its identity will change on every render. Including it in the
   * dependencies would cause the cleanup function to run on every update, not
   * just unmount, leading to the input being cleared whenever the component
   * re-renders. This setup ensures the input is only cleared when the component
   * unmounts, as intended.
   */
  React.useEffect(() => {
    return () => {
      if (onClear) onClear();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const {
    activeDescendantId,
    isMenuOpen,
    listId
  } = context.useDropdownContext();

  // Ref to track if the component has already been initialized
  const isFirstRenderRef = React.useRef(true);
  const handleKeyDown = useKeydownNavigation();
  const isAppleDevice = utils.isAppleDevice();

  // When the Filtermenu is opened, the searchbox should be focused in order for
  // the keyboard navigation to work.
  const autoFocusOnOpen = React.useCallback(node => {
    if (node && isMenuOpen && isFirstRenderRef.current) {
      node.focus({
        preventScroll: true
      });
      isFirstRenderRef.current = false;
    }
  }, [isMenuOpen]);
  const a11yProps = {
    'aria-activedescendant': isAppleDevice ? undefined : activeDescendantId,
    'aria-autocomplete': 'list',
    'aria-controls': listId,
    'aria-expanded': isMenuOpen,
    autoComplete: 'off',
    autoCorrect: 'off',
    role: 'combobox',
    spellCheck: 'false'
  };
  return /*#__PURE__*/jsxRuntime.jsxs(React.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(search_input.SearchInput, {
      ...mergeProps.mergeProps(consumerProps, a11yProps, {
        onKeyDown: handleKeyDown,
        onClear
      }),
      ref: utils.mergeRefs(autoFocusOnOpen, forwardedRef)
    }), /*#__PURE__*/jsxRuntime.jsx(combobox_search_input.LiveRegion, {})]
  });
});
FilterMenuSearchInput.displayName = 'FilterMenuSearchInput';
const supportedKeys = ['ArrowUp', 'ArrowDown', 'Home', 'End', 'Escape', 'Enter', 'Tab'];
function isSupportedKey(key) {
  return supportedKeys.includes(key);
}
function useKeydownNavigation() {
  const {
    clickSelectedItem,
    closeMenu,
    goToFirstMenuItem,
    goToLastMenuItem,
    goToNextMenuItem,
    goToPreviousMenuItem
  } = context.useDropdownContext();
  return React.useCallback(event => {
    // If we don't have a case for the key, we can return early.
    if (!isSupportedKey(event.code)) return;
    switch (event.code) {
      case 'ArrowUp':
        {
          event.preventDefault();
          goToPreviousMenuItem();
          return;
        }
      case 'ArrowDown':
        {
          event.preventDefault();
          goToNextMenuItem();
          return;
        }
      case 'Home':
        {
          event.preventDefault();
          goToFirstMenuItem();
          return;
        }
      case 'End':
        {
          event.preventDefault();
          goToLastMenuItem();
          return;
        }
      case 'Escape':
        {
          closeMenu();
          return;
        }
      case 'Enter':
        {
          event.preventDefault();
          clickSelectedItem();
          return;
        }
      case 'Tab':
        {
          closeMenu();
          return;
        }
      default:
        emery.assertNever(event.code);
    }
  }, [clickSelectedItem, closeMenu, goToFirstMenuItem, goToLastMenuItem, goToNextMenuItem, goToPreviousMenuItem]);
}

exports.FilterMenuSearchInput = FilterMenuSearchInput;
